<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>TypeScript Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="slides/revealjs/reveal.js/dist/theme/solarized.css"
    />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link
      rel="stylesheet"
      href="slides/revealjs/highlight-js-github-theme.css"
    />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal" data-beta="true">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>TypeScript Advanced</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3>
              <span class="transparent-bg">Repository (bitte klonen ü§ì)</span>
            </h3>
            <p>
              <code class="transparent-bg" style="font-size: 50px"
                ><b
                  >https://github.com/nilshartmann/typescript-advanced-workshop</b
                ></code
              >
            </p>
          </div>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2023-wdc.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://react.schule/wdc2023-typescript">
                  https://react.schule/wdc2023-typescript</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p style="margin-top: 2rem">
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>
          <p></p>
          <p style="margin-top: 5rem">
            Java | JavaScript, TypeScript | React | GraphQL
          </p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ######################################################  -->
        <section data-markdown>
          <textarea data-template>
### Vorbereitung f√ºr √úbungen
* Bitte klont das Repository: https://github.com/nilshartmann/typescript-advanced-workshop
* Im Root-Verzeichnis `npm install` ausf√ºhren, dann wird TS 4.9 installiert
* In Eurer IDE/Editor sicherstellen, dass diese Version auch verwendet wird
* Die Slides findet ihr im Root-Verzeichnis: `2023-wdc.html`
  * Die k√∂nnt ihr im Brower √∂ffnen
* Im `src`-Verzeichnis findet ihr (fast) alle Beispiele aus den Slides auch im Quellcode
* Wir machen aber gemeinsam √úbungen, dann habt ihr Zeit, Dinge selbst auszuprobieren
---
## Agenda

* [Grundlagen](#/t-intro)
* [Generics](#/t-generics)
* [Mapped Types](#/t-mapped-types)
* [Conditional Types](#/t-conditional-types)
  * [Type inference mit Conditional Types](#/t-conditional-types-inference)
* [Template Literale](#/t-template-literale)
  * [Remapping von Keys](#/t-template-literale-remapping)
  * [Intersection und Union Types (Exkurs)](#/t-intersection-und-union-types)
  * [Conditional Types mit Template Literalen](#/t-template-literale-conditional-types)
---
### Unser Workshop heute...

* Wir konzentrieren uns heute nur auf die Typ-Ebene
* Die gezeigten Beispiele kommen daher ohne Implementierung aus
* Ich m√∂chte Euch zeigen, wie ihr komplexe Typ-Definitionen schreiben k√∂nnt, von denen Verwender Eurer APIs dann profitieren
  * Die APIs kann man nutzen, ohne viel TypeScript Typen schreiben zu m√ºssen
  * Verwendung der APIs ist aber trotzdem typsicher
  
---
## Grundlagen
<!-- .slide: id="t-intro" -->
---
### Zwei kleine Tipps
* TypeScript online im Playground ausf√ºhren: https://www.typescriptlang.org/play

* Typen in der IDE/Editor anzeigen:
  * In der Regel k√∂nnt ihr Euch in Eurem Editor oder Eurer IDE den Typen einer Variable anzeigen lassen, in dem ihr mit der Maus dar√ºber fahrt  
  * Im [TypeScript Playground](https://www.typescriptlang.org/play) k√∂nnt ihr mit `// ?^` unter einer Variablen Euch deren Typen anzeigen lassen
  * ![Tooltip](./slides/images/screenshot-type-tooltip.png)
  * F√ºr VS Code gibt es dazu eine [Extension](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-twoslash-queries)

---
### Type Aliase
* Mit dem Schl√ºsselwort [`type`](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases) wird ein __Type Alias__ erzeugt.
* Ein Type Alias ist nur ein (anderer) Name f√ºr einen Typen
* Man kann immer entweder einen Type Alias oder einen kompletten Typen hinschreiben
* Beispiele:
  * ```typescript
    declare function createPerson(firstname: string, address: {city: string} ): 
                                        { firstname: string, address: { city: string } };

    ```
  * ist identisch mit:  
  * ```typescript
    type Address = {
      city: string;
    }
    type Person = {
      firstname: string
      address: { city: string }
    }
    declare function createPerson(firstname: string, address: Address ): Person;
  ```

  * ...und auch das ist identisch:
  * ```typescript
    type Address = {
      city: string;
    }
    type Person = {
      firstname: string
      address: Address
    }
    declare function createPerson(firstname: string, address: Address ): Person;
  ```
* Man verwendet immer das, was am besten passt
---
### Index Access
* Mit dem Index Operator kannst Du in JavaScript auf _Werte_ aus einem _Objekt_ zugreifen:
* ```typescript
  const person = {
    firstname: "Klaus",
    address: { city: "Hamburg", street: "Reeperbahn" }
  }

  const address = person["address"];
  ```
* Etwas √§hnliches kannst Du auch mit _Typen_ machen, wenn du den _Typ_ eines Properties ben√∂tigst:
* ```typescript
  type Person = {
    firstname: string
    address: { city: string }
  }

  type Address = Person["address"]
  ```
* Das kann hilfreich sein, wenn Du einen Typen hast, den Du nicht selbst beschrieben hast. 
  * Zum Beispiel wenn der Typ aus einer Bibliothek stammt oder von einem Code Generator erzeugt wurde.

---
### Index Access #2
* Wenn Du den Typen eines Arrays ben√∂tigst, kannst Du statt eines Property-Namens `[number]` hinschreiben:
* ```typescript
  type Person = {
    contacts: [
      {
        email: string;
        phone: string;
      }
    ];
  };

  type Contacts = Person["contacts"];        // Array<{ email: string, phone: string }>
  type Contact = Person["contacts"][number]; //       { email: string, phone: string }

  declare function addContact(c: Contact): void;

  addContact({email: "nils@nilshartmann.net", phone: "..."})
  ```
---
### Union Types
* Variablen, Parameter etc. k√∂nnen mehr als einen Typ annehmen:            
* ```typescript
    type Person = { name: string };
    type Movie = { title: string };

    type PersonOrMovie = Person | Movie;

    function printNameOrTitle(obj: PersonOrMovie) { 

      console.log(obj.title); // ERR: Property 'title' does not 
                              // exist on type 'Person | Movie'
    
      if ("title" in obj) { // Abfrage ist ein "Type Guard"
        // obj ist Movie hier, title ist definiert
        console.log(obj.title);
      } else {
        // obj ist Person hier: name ist definiert
        console.log(obj.name);
      }
    }

    printNameOrTitle( { name: "Klaus" } ); // OK

    printNameOrTitle( { title: "TypeScript Deep Dive" } ); // OK

    printNameOrTitle( { label: "Save" } ); // ERR
  ```
---
### Literal Types
* Mit einem [Literal Type](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types) kannst Du einen Typen definieren, der einen konkreten String darstellt 
* ```typescript
  // Beispiel:             
  type Answer = "Yes" | "No" | "I_dont_care";

  const a1:Answer = "Yes"; // OK
  const a2:View = "Maybe" // FEHLER
  ```
* ```typescript
  function fillIn(a: Answer) {
    if (a === "Yes") { ... } // ok
    if (a === "Maybe") { ... } // error: immer false
  }

  fillIn("I_dont_care"); //OK
  fillIn("Maybe"); // ERROR
  ```
* Das funktioniert auch f√ºr number 
* ```typescript
  type OneOrZero = 1 | 0;
  declare function toggleBit(v: OneOrZero): void;
  toggleBit(1); // OK
  toggleBit(2); // ERR
  ```
---
### keyof

* [`keyof`](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) liefert einen Union Typen zur√ºck, der alle Keys eines Objektes enth√§lt
* ```typescript
  type Person = {
    firstname: string;
    lastname: string;
  }
  type PersonKeys = keyof Person; // "firstname" | "lastname"

  ```
* Damit kann man zum Beispiel erzwingen, das ein Funktionsparameter nur g√ºltige
  Keys eines Objekts aufnehmen kann:
* ```typescript
  declare function logPropertyOfPerson(propName: keyof Person): void;

  logPropertyOfPerson("firstname"); // OK
  logPropertyOfPerson("age") // ERR: Argument of type '"age"' is not 
                             // assignable to parameter of type 'keyof Person'

  ```

 
---
### Der typeof-Operator

* Der `typeof`-Operator in JavaScript liefert den _Wert_ einer Variablen zur Laufzeit zur√ºck.
* Mit dem [`typeof`-Operator von TypeScript](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#handbook-content) kann der Typ eines Werts auf Typ-Ebene ermittelt werden.
  * Im Grunde das, was die IDE tut, wenn ihr mit der Maus √ºber einen Variable fahrt
* ```typescript
  const languages = {
    de: "DE",
    en: "EN"
  }

  type TLanguages = typeof languages;          // TLanguages ist TYPE, languages ist WERT
        // { de: string; en: string; }

  export declare function translateMessage(msg: string, lang: keyof TLanguages): string;

  // oder:
  type TLanguageKeys = keyof typeof languages;
  export declare function translateMessage(msg: string, lang: TLanguageKeys): string;
  ```
* Das geht f√ºr alle m√∂glichen Dinge, auch f√ºr Funktionen:
* ```typescript
  declare function sayHello(name: string): string | null;

  type Fn = typeof sayHello;
       // (name: string) => string | null
  ```
  
---
### √úbung: Grundlagen
* Eine kurze √úbung zum "warm werden"
* In der Datei `src/190_intro_uebung.ts` findest Du eine kleine √úbung beschrieben
* Du musst einen Union Typen erzeugen
* Mehr Informationen findest Du in der Datei, in der Du die √úbung auch machen kannst
* Wir f√ºhren heute keinen Code aus, sondern achten nur auf das TypeScript TypeChecking Ergebnis
* Die erwarteten Fehler (bzw. nicht-Fehler) habe ich Euch in die Datei geschrieben.
* Eine m√∂gliche L√∂sung findest Du in `190s_intro_uebung.ts` ("S" wie Solution üòä)

---
## Generics
<!-- .slide: id="t-generics" -->

---
### Generics
* **Beispiel**: eine (JavaScript-)Funktion, die einen beliebigen Wert validiert. Wenn der Wert g√ºltig ist,
wird er von der Funktion unver√§ndert zur√ºckgegeben, ansonsten wirft die Funktion einen `Error` und kehrt nicht zur√ºck.
* Mit `any` k√∂nnen wir Funktionen beschreiben, die alle m√∂glichen Typen entgegennehmen
  und/oder zur√ºckliefern
  * ```typescript
    declare function validate(obj: any): any
    ```
* Was machen wir aber, wenn wir den √ºbergebenen Typen (f√ºr `obj`) an anderer Stelle ben√∂tigen?
  * Zum Beispiel, um sicherzustellen, dass der R√ºckgabe-Typ dem Typen eines Parameters entspricht?
* ```typescript
  const p = validate("hallo"); // p soll string sein (ist: any üòî)
  const n = validate(123); // n soll number sein (ist: any üòî)
  ```
  
---
### Generics
* F√ºr Funktionen (und Typen) k√∂nnen **Typ Variablen** definiert werden
* Fast wie Funktionsparameter, nur dass keine __Werte__, sondern __Typen__ angegeben werden
* Die Typ Variable wird deklariert (`<VariablenName>`) und kann dann in der gesamten Funktionssignatur bzw. Typ-Definition verwendet werden
* Vorheriges Beispiel, jetzt mit Generics und gew√ºnschtem Verhalten:
  * ```typescript
    // "O" ist Typ Variable

    declare function validate<O>(o: O): O
    const p = validate("hallo"); // p jetzt string üòä
    const n = validate(123); // n jetzt number üòä
    ```
* Weitere Beispiele
  * Fachliche Idee: Die Funktion liefert den √ºbergebenen Wert zur√ºck
    oder "null", falls der Wert ung√ºltig ist (was auch immer "ung√ºltig" hier bedeutet)  
  * ```typescript
      declare function validate<O>(o: O): O | null
    ```
  * Ein Typ, der entweder eine Liste von Dingen ist oder `null`
    * (fachlich bescheuertes Beispiel, bessere Beispiele folgen...)
  * ```typescript
      type ListOrNull<O> = Array<O> | null;
    ```
---
### Generics
* Beim Verwenden in einer Funktion wird der __Typ__ entweder vom √ºbergebenen __Wert__ abgeleitet:
* ```typescript
  declare function validate<O>(o: O): O | null
  const x = validate("Hallo"); // O ist string, x ist string | null
  const y = validate(7); // O ist number, y ist number | null
  ```
* ...oder der Typ wird explizit angegeben. Dann muss der __Wert__ dem angegebenen __Typen__ entsprechen:
* ```typescript
  validate<string>("Hallo"); // O ist string, Argument ist string: Alles OK!
  validate<string>(7); // O ist string, Argument ist number:
                       // ERR: Argument of type 'number' is not assignable to parameter of type 'string'
  ```
---
### Generics: Default-Werte
* Analog zu "normalen" Funktionsargumenten, k√∂nnen auch bei Generics Default**typen** angegeben werden
* Wie bei Funktionsargumenten kann auch nur der letzte bzw. die letzten Argumente Default-Typen haben
* ```typescript
  declare function validate<O, R = string>(o: O): O | R

  validate(7); // R√ºckgabeTyp: number | string 
  validate<number>(7); // R√ºckgabeTyp: number | string 
  validate<number, null>(7); // R√ºckgabeTyp: number | null
  validate<number, boolean>(7); // R√ºckgabeTyp: number | boolean
  ```
* ```typescript
  type Tuple<X, Y = string> = [X, Y];

  type TupleOfNumberAndStrings = Tuple<number>; // [number, string]
  type TupleOfStringAndBoolean = Tuple<string, boolean>; // [string, boolean]
  ```
* Wie bei Funktionsargumenten, k√∂nnen auch Typ Variablen an andere Typen weitergegeben werden:
* ```typescript
  type ReactUseStateTuple<V> = Tuple<V, (newValue: V) => void>;
         // [ V, function(a: V): void ]
  ```

---
### Generic: Constraints   
* Wie bei "normalen" Argumente, k√∂nnen die Typ-Argumente Einschr√§nkungen haben:
* Die Einschr√§nkungen werden mnit `extends` definiert
  * Der √ºbergenene Typ muss dann derselbe oder ein davon erweiterter sein:
* Beispiel: beliebiges Objekt erlaubt  
* ```typescript
  declare function validateObject<O extends object>(o: O): O | null;

  validateObject({name: "Klaus"}); // OK
  validateObject("Klaus");         // ERR: Argument of type 'string' is not 
                                   // assignable to parameter of type 'object'

  ```
* Beispiel: nur Objekte mit bestimmter Struktur erlaubt  
* ```typescript
  type Person = { firstname: string | null };

  declare function getOrDefault<P extends Person>(p: P): P;

  getOrDefault( { } ); // ERR: Property 'firstname' is missing in type '{}' 
                       // but required in type 'Person'
  ```
---
### Generics mit Union Typen  

* Wenn man einen Union Type als Constraint angibt, muss der √ºbergebene Typ einem
  der im Union-Typen enthaltenen Typen entsprechen:  
* ```typescript
  type Color = "red" | "blue" | "green";

  declare function bgColor<C extends Color> (c: Color): { backgroundColor: C };

  bgColor("red"); // OK
  bgColor("white"); // Argument of type '"white"' is not 
                    // assignable to parameter of type 'Color'
  ```
* ```typescript
  type ListOfStringsOrBooleans<X extends string|boolean> = Array<X>;

  const c1: ListOfStringsOrBooleans<string> = ["a"]; // Ok
  const c2: ListOfStringsOrBooleans<boolean> = [true]; // Ok
  const c3: ListOfStringsOrBooleans<string|boolean> = [true, "jo!"]; // Ok

  const c4: ListOfStringsOrBooleans<number> = [4]; // ERR Type 'number' does not satisfy 
                                                   // the constraint 'string | boolean'

  declare function validateNumberOrString<O extends string|number>(o: O): O | null    
  ```

---
### √úbung Generics
* Beschreibe eine Typsichere `createSetter`-Funktion. Die Funktion soll eine fiktive Setter-Funktion f√ºr ein Property eines
beliebigen Objektes zur√ºckliefern.
  * Fachliche Idee: in der Setter-Funktion k√∂nnen z.B. √úberpr√ºfungen durchgef√ºhrt werden oder die Setter-Funktion k√∂nnte den Wert in eine DB schreiben o.√§.
* Die Funktion soll zwei Parameter haben:
  1. Ein beliebiges Objekt (`someObject`), 2. Den Namen eines Keys aus dem Objekt (`aKey`)
* Der R√ºckgabe-Typ soll eine Funktion sein, die ihrerseits ein Argument hat, das vom Typ des Properties aus dem √ºbergebenen
  Objekt (`someObject`) ist, so dass diese Funktion aufgerufen werden kann, um den Wert des Objektes zu setzen. 
* In JavaScript s√§he das so aus:
  * ```javascript
    function createSetter(someObject, aKey) { /* ... */ } 

    const ageSetter = createSetter({firstname: "Klaus", age: 32}, "firstname");
    ageSetter(33);
    ```
* Die √úbung kannst Du in `src/290_uebung_generics.ts` machen. Dort findest Du weitere Hinweise.
* M√∂gliche L√∂sungen findest Du in `src/290s_uebung_generics.ts` (`s` wie `solution`)
---
## Mapped Types
<!-- .slide: id="t-mapped-types" -->

---
### Mapped Types
* Mit einem [Mapped Type](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) kannst Du aus einem bestehenden TypeScript Typen einen anderen erzeugen.
* Du kannst damit Logik, die in JavaScript auf Werte-Ebene funktioniert auf Typ-Ebene nachbauen
* Dazu ein Beispiel: eine Funktion, die jedes Feld eines Objekts validiert und ein neues Objekt mit dem Validierungsergebnis zur√ºckliefert:
* ```javascript
  function validateField(value) {
    // Validierungslogik...
    return true; // oder false
  }

  function validateObject(object) {
    if (object == null || typeof object !== "object") {
      throw new Error("invalid type");
    }
    const result = {};
    Object.keys(object).forEach(k => { 
      result[k] = validateField(object[k]);
    });
    return result;
  }
  ```
* Die Funktion nimmt ein beliebiges Objekt entgegen und liefert ein neues Objekt zur√ºck:
  * in diesem sind dieselben Keys wie im Ausgangsobjekt vorhanden
  * Die Werte sind aber in diesem Fall jeweils `true` oder `false` (je nachdem, was die fiktive
  `validateField`-Funktion zur√ºckgegeben hat.)

---
### Mapped Types
* Eine - unzureichende - Typ-Definition f√ºr diese Funktion k√∂nnte so aussehen:
* ```typescript
  declare function validateObject(o: object): object;

  const result = validateObject( { firstname: "Klaus", age: 32} );
    //  ^? result: object

  ```
* So k√§me ein _beliebiges_ oder _allgemeines_ Objekt zur√ºck. Wir wissen aber eigentlich genauer, wie das Objekt aussieht, das zur√ºckgeliefert wird.
* ```typescript
  const result = validateObject( { firstname: "Klaus", age: 32} );
    //  pr√§ziser R√ºckgabetype w√§re: { firstname: boolean, age: boolean }

  ```
* Mit einem Mapped Type k√∂nnen wir diese Regel auf Typ-Ebene dynamisch umsetzen, und so diesen pr√§zisen R√ºckgabe-Typ erzeugen.
---
### Mapped Types
* Um den R√ºckgabe-Typ von `validateObject` zu beschreiben, k√∂nnen wir einen eigenen Typen definieren (`ValidatedObject`)
* Der `ValidatePerson`-Typ kann generisch beschrieben werden, so dass er _automatisch_ alle Properties
  aus einem Typen enth√§lt, deren Typ aber nun jeweils `boolean` ist. F√ºr den konkreten Typen `Person` s√§he das so aus:
  * ```typescript
      type Person = { firstname: string; age: number };
      type ValidatedObject = {
        [Key in keyof Person]: boolean
      }

      // ^?  { firstname: boolean; age: boolean }
    ```
* Den Ausdruck `keyof Person` kennen wir schon: hier wird ein Union Typ zur√ºckgeliefert, der aus allen Keys des Objekts besteht
* Mit `[Key in keyof Person]` wird an dieser Stelle √ºber alle Keys in dem Objekt "iteriert" und der Typ des jeweiligen Keys in die Typ Variable `Key` geschrieben
  * im Beispiel der `Person` w√§re das also: `firstname` und dann `age`
  * `Key` ist ein Variablenname, den ihr frei vergeben k√∂nnt.
* Auf der rechten Seite vom Doppelpunkt steht (wie gewohnt) der Typ f√ºr das jeweilige Property (hier also: `boolean`)  

---
### Mapped Types
* Nat√ºrlich k√∂nnen wir alle m√∂glichen Ver√§nderungen im Ziel-Objekt vorgenommen werden, z.B. auch `readonly` hinzugef√ºgt, oder Felder optional gemacht werden:
  * ```typescript
    type ValidatedPerson = {
      readonly [Key in keyof Person]?: boolean
    }

    //  ^?  { readonly firstname?: boolean, readonly age?: boolean }
    ```
* Es gibt bereits fertige [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html) f√ºr eine Vielzahl typischer Anwendungsf√§lle,
  z.B. [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype), [Required](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype) oder [Readonly](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)

---
### Mapped Types #2
* Im vorherigen Beispiel haben wir allen Eintr√§gen eines Objekts einen fixen neuen Typen (`boolean`) zu gewiesen.
* Es gibt aber auch F√§lle, in denen der Typ eines Eintrags aus dem Typen des Originals abgeleitet werden soll.
* In einer modifizierten Variante der `validate`-Funktion, liefert diese nun nicht mehr `boolean` zur√ºck, sondern den Original-Wert eines Feldes oder `null`, falls dieser ung√ºltig ist:
* ```javascript
  function validateField(value) {
    // Validierungslogik...
    return value; // oder null falls ung√ºltig
  }

  function validateObject(object) {
    // unver√§ndert...
  }  
  ```
* Wenn wir ein Objekt des `Person`-Typen validieren lassen, m√ºsste der R√ºckgabe-Typ folglich so aussehen:
* ```typescript
  const result = validateObject( { firstname: "Klaus", age: 32} )
     // ^?  { firstname: string | null, age: number | null }
  ```
---
### Mapped Types #2  
* √úber den Index Access k√∂nnen wir beim Erzeugen des neuen Typen auf die urspr√ºnglichen Typen der Properties des Original-Typen zugreifen
* Damit k√∂nnen wir zum Beispiel einen Typen bauen, der alle Properties aus dem urspr√ºnglichen Typen hat, diese sind aber im neuen Typen nullable:
* ```typescript
  type Person = {
    firstname: string,
    age: number
  }

  type ValidatedObject = {
    [Key in keyof Person]: Person[Key] | null
  }
  // ^? { firstname: string | null, age: number | null }

  declare function validate(p: Person): ValidatedObject;

                                          
  ```
---
### Mapped Types mit Generics

* Unsere `validate`-Funktion soll eigentlich _beliebige_ Objekte validieren und nicht nur `Person`-Objekte.
* Daher muss unser `ValidatedObject`-Typ _generisch_ sein und eine Typ-Variable verwenden
* Die Typ-Variable gibt den zu transformierenden Typen an (z.B. `Person`)
* Damit kannst Du _beliebige_ Typen in andere Typen transformieren:
* ```typescript
  type ValidatedObject<OBJECT extends object> = {
    [Key in keyof OBJECT]: OBJECT[Key] | null
  }

  type ValidatedContact = ValidatedObject<{phone: string, mobile: boolean}>;
        // ^? { phone: string | null, mobile: boolean | null }
  ```
* Wie muss die Signatur von der `validate`-Funktion jetzt aussehen? ü§î
* ```typescript
  declare function validate<O extends object>(o: O): ValidatedObject<O>;
  
  const person = { firstname: "Klaus", age: 123 };
  const result = validate(person);
        // ^? { firstname: string | null, age: number | null }

  ```
---
### Exkurs: "Flattening von Typen"
* Beim Bauen von Typen, z.B. durch Intersections, wird die Darstellung des erzeugen Typen ab und an "un√ºbersichtlich":

* ```typescript
    interface A {
      firstname: string;
    }
    
    type B = A & {
      lastname: string;
    };

    // ^? type B = A & { lastname: string }

    // sch√∂ner w√§re: type B = { firstname: string, lastname: string}
    ```
* Es gibt mehrere "Tricks", wie man dieses Verhalten erzeugen kann. F√ºr mich funktionier am besten dieser Utility Typ:
* ```typescript
  type Flatten<O, T extends keyof O = keyof O> = {
    [P in T]: O[P];
  };
  ```
* ```typescript
  type Flatten_B = Flatten<B>
  //          ?^  type Flatten_B = { firstname: string, lastname: string}
  ```
* oder, selbes Ergebnis, direkt beim Erzeugen des Typen verwenden:
  ```typescript
    type B = Flatten<A & { lastname: string }> 
  ```
  
---
### √úbung Mapped Types:

* Schreibe die Typ-Definitionen f√ºr eine weitere Variante der Validation-Funktion!
* Der Aufrufer der validate-Funktion muss nun auch ein Objekt mit Validierungsregeln √ºbergeben.
  * Dieses Objekt soll alle Keys aus dem zu validierenden Objekt enthalten
  * Diese sind jedoch dann die Validierungsfunktion
* ```typescript
    // In JavaScript
    function validate(anObject, validators) { /* ... */ }

    const person = {
      firstname: "Klaus",
      age: 32
    }

    const personValidators = {
      firstname(f) { return f.length > 3 },
      age(a) { return a < 18 }
    }

    const result = validate(person, personValidators);
    // { firstname: true, age: false }
  ```
* In `src/390_uebung_mapped_type.ts` findest Du Ausgangsmaterial mit Hinweisen.
* M√∂gliche L√∂sungen findest Du in `src/390s_uebung_mapped_type.ts`

---
### √úbung Mapped Types    
<!-- .slide: data-visibility="hidden" -->

* <!-- .element: class="todo" -->Hinweisen: entweder Typ f√ºr Validator-Objekt erst bauen, oder die validator-Funktionen beim Aufruf der Methode angeben, sonst kann TS die Argumente nicht ableiten
* <!-- .element: class="todo" -->deswegen erst `ValidatorsObjekt` bauen (lassen)
* Die `validate`-Funktion soll zwei Parameter haben:
  1. Das zu validierende Objekt 
  2. Ein Objekt, das Funktionen zum Validieren enth√§lt
    - F√ºr jedes Property aus dem zu validierenden Objekt soll es eine (Callback-)_Funktion_ geben, die so hei√üt, wie das Property
    - Diese Funktion soll einen Parameter haben, der denselben Typ wie das Property hat und `true` oder `false` zur√ºckliefern (wie gesehen)
* Die `validate`-Funktion soll ein Objekt zur√ºckliefern, das dieselben Keys wie das zu validierende Objekt hat. Die Typen sollen aber jeweils `boolean` und `readonly` sein.
* Dann sollte folgendes funktionieren bzw. einen Fehler erzeugen:
* **Optional:**
  - Kannst Du die Signatur so bauen, dass das `validateFn`-Objekt eine Untermenge des zu validierenden Objekts ist? Man also f√ºr ein Feld im zu validierenden Objekt eine Validator-Callback-Funktion angeben kann oder nicht?
<!-- .element: class="todo" -->todo: L√∂sung lieber in √úbungsdatei, 
* ```typescript
const p = { firstname: "Klaus", lastname: "Meier", age: 32 };
personValidator.age?.(7); // OK
personValidator.age?.("fadfas"); // Argument of type 'string' is not assignable to parameter of type 'number'

  ```
---
### M√∂gliche L√∂sung
<!-- .slide: data-visibility="hidden" -->
<!-- .slide: class="left" -->
* ```typescript
  // Ein Typ f√ºr das Ergebnis der validate-Funktion
  type ValidationResult<O> = {
    readonly [K in keyof O]: boolean;
  };

  // Typ f√ºr eine Validator Callback-Funktion
  type ValidatorFunction<V> = (value: V) => boolean;

  // Typ f√ºr das Objekt, das die Validator Callback-Funktionen enth√§lt
  type ValidatorObject<O extends object> = {
    readonly [K in keyof O]: ValidatorFunction<O[K]>;
  };

  // die validateObjekt-Funktion
  declare function validateObject<O extends object>(
    o: O,
    validators: ValidatorObject<O>
  ) => ValidationResult<O>;

  // Teil 2: Validator-Funktionen sind optional
  declare function validateObject<O extends object>(
    o: O,
    validators: ValidatorObject<Partial<O>>
  ) => ValidationResult<O>;  
  ```

---
## Conditional Types
<!-- .slide: id="t-conditional-types" -->
### Conditional Types: 
* F√ºr Konstellationen, in denen ein Typ abh√§ngig von einem anderen verwendet werden, gibt es _Conditional Types_.
* Dazu ein Beispiel:
  * Eine Funktion nimmt einen `string` oder `null` entgegen. 
  * Wenn sie mit `string` aufgerufen wurde, soll sie dessen L√§nge zur√ºckgeben (`number`)
  * Wenn sie mit `null` aufgerufen wurde, soll sie `null` zur√ºckliefern
  * Ganz naiv geht das leider nicht:
  * ```typescript
    // So geht's nicht üò¢
    declare function getLength(s: string | null): number | null; 

    const a = getLength("123"); // a: number | null 
    const b = getLength(null); // b: number | null
    ```

---
### Conditional Types

* Mit [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) kannst Du abh√§ngig von einer Bedingung einen Typen oder einen anderen Typen ausw√§hlen
* Die Syntax dabei ist identisch mit dem tern√§ren Operator (`?`) in JavaScript (`a === true ? "ja!" : "nein!"`)
* Nur dass dabei _Typen_ statt _Werte_ angegeben werden:
  * ```typescript
    type NumberOrNull<O> = O extends string ? number : null;

    type S = NumberOrNull<"huhu"> // N = number
    type N = NumberOrNull<123> // N = null
    type A = NumberOrNull<true>; // A = null
    ```
  * ```typescript
    type IsPerson<O> = O extends { firstname: string, lastname: string} ? true : false
    ```

* Conditional Types lassen sich verschachteln (genau wie beim tern√§ren Operator):
  * ```typescript
    type NumberOrStringOrNull<O> = O extends string ? number 
                                 : O extends boolean ? string 
                                 : null

    type T1 = NumberOrStringOrNull<"huhu">; // T1 = string
    type T2 = NumberOrStringOrNull<123>; // T2 = null
    type T3 = NumberOrStringOrNull<true>; // T3 = string     
    ```
    
---
### Verwendung von Conditional Types
    
* Zur√ºck zu der `getLength`-Funktion: 
  * ```typescript
    // So geht's immer noch nicht üò¢
    declare function getLength(s: string | null): number | null; 
    ```
* Mit Generics und einem Conditional Type l√§sst sich das nun umsetzen: 
* ```typescript
    declare function getLength<O extends string | null>(s: O): O extends string ? number : null;

    const a = getLength("123"); // a: number
    const b = getLength(null); // b: null
  ```
* K√∂nnen wir einen `If-Then-Else`-Typen bauen, der uns den Conditional Type verallgemeinert? ü§î
  * ```typescript
    type IfThenElse<Current, I, T, E> = Current extends I ? T : E 

    declare function getLength<O extends string | null>(s: O): IfThenElse<O, string, number, null>;
    ```
---
### Conditional Types mit Union Types

* Wenn Du einen _Union Type_ √ºbergibst, wird die √úberpr√ºfung f√ºr jeden Typen aus dem Union Type durchgef√ºhrt und ein neuer Union Type zur√ºckgeliefert:
* ```typescript
  type NumberOrNull<O> = O extends string ? number : null;
  ```

* ```typescript
  type R = NumberOrNull<string | null | boolean>; 
    // ^? = number | null:

    // - 'string' wird zu 'number'
    // - 'null' wird null (kein string)
    // - 'boolean' wird null (kein string)
  ```
* Das ist also das gleiche (nur in kompliziert) wie:  
* ```typescript
  type R = NumberOrNull<string> | NumberOrNull<null> | NumberOrNull<boolean>;
  ```
  
---
### Conditional Types mit `never`
* **Ein Beispiel:** eine Funktion, die sicherstellt, dass ein √ºbergebener Wert nicht `null` ist
  * Wenn der √ºbergebene Wert `null` ist, wirft die Funktion einen Fehler
  * Wenn der Wert nicht `null` ist, liefert die Funktion den Wert unver√§ndert zur√ºck
* ```typescript
  declare function ensureNotNull<O>(o: O): O;

  // oder noch expliziter:
  declare function ensureNotNull<O>(o: O | null): O;
  ```
  
* In diesem Fall ist die Menge der potentiellen R√ºckgabe-Typen also _kleiner_ als die Menge der Eingabe-Typen:
  - w√§hrend als Eingabe _alle_ m√∂glichen Typen erlaubt sind,
  - sind als R√ºckgabe-Typen alle m√∂glichen Typen _bis auf `null`_ m√∂glich
* Dazu m√ºssen wir den `null`-Typen herausfiltern. Das k√∂nnen wir mit `never` machen.
---
### Conditional Types mit `never`
* Wenn `never` in einem _Union Type_ vorkommt, wird dieser Typ "herausgefiltert"
* ```typescript
  type X = string | boolean | never; // X = string | boolean
  ```
* Das kanst Du nutzen, um mit einem Conditional Type aus einer Liste von Typen welche herauszufiltern
* ```typescript
  type NotNull<O> = O extends null ? never : O;

  type T = NotNull<string>; T = string
  type T1 = NotNull<string | null>; // T1 = string
  type T2 = NotNull<string | boolean | null | undefined>; // T2 = string | boolean | undefined

  // Macht hier kein Sinn, aber s. weiteres Beispiel sp√§ter
  type TX = NotNull<null>; // TX = never
  ```
* `extends` kann ebenfalls einen Union Typen aufnehmen.
* Die Bedigungt ist dann wahr, wenn der gepr√ºfte Typ _einem_ der in `extends` angegebenen Typen entspricht:

* ```typescript
  type NotNullOrUndefined<O> = O extends null | undefined ? never : O

  type T3 = NotNullOrUndefined<string>; // T3 = string  
  type T4 = NotNullOrUndefined<string | null>; // T4 = string
  type T5 = NotNullOrUndefined<string | boolean | undefined>; // T5 = string | boolean
  ```
---
### Conditional Types mit `never`

* Damit k√∂nnen wir auch f√ºr die `ensureNotNull` korrekte Typen hinschreiben: 
* ```typescript
  type NotNull<O> = O extends null ? never : O

  declare function ensureNotNull<O>(o: O): NotNull<O>;

  const c = ensureNotNull("huhu"); 
     // ^? string

  // hier macht 'never' Sinn, da die Funktion hier nicht zur√ºckkommt:
  const b = ensureNotNull(null); 
     // ^? never

  ```

---
### Type Inference mit Conditional Types
<!-- .slide: id="t-conditional-types-inference" -->


* Mit einem Conditional Type k√∂nnen wir nicht nur Typen √ºberpr√ºfen, sondern auch Typen _extrahieren_ lassen
* Beispiel:
  * Eine Funktion nimmt einen Parameter entgegen
  * Der R√ºckgabetyp soll dem Typen des Parameters entsprechen. Wie das geht, haben wir schon gesehen:
  * ```typescript
    declare function check<O>(o: O): O;
    ```
  * Wenn der √ºbergebene Parameter aber selbst eine Funktion ist, soll deren(!) R√ºckgabetyp zur√ºckgeliefert werden:
  * ```typescript
    check( () => 123 ); // R√ºckgabetyp soll number sein
    check( () => "Hallo" ); // R√ºckgabetyp soll string sein
    ```
---
###  Type Inference mit Conditional Types 
  * Mit einem Conditional-Type k√∂nnen wir pr√ºfen, ob etwas ein Funktion ist.
  * Dazu schreiben wir als zu pr√ºfenden Typ eine (allgemeine) Funktionssignatur hin:
  * ```typescript
    O extends (...args: any) => any ? /* Funktion */ : /* Keine Funktion */
    ```
* Wenn der Ausdruck des Conditional Types _true_ ist, wissen wir das es eine Funktion ist. In dem Fall k√∂nnen wir mit `infer` die Typen der Parameter
  und/oder des R√ºckgabewertes extrahieren und in eine neue Typ-Variable schreiben lassen.
  * ```typescript
  O extends (...args: any) => infer A ? 
     /* Funktion: hier haben wir jetzt O und A */ 
     : 
     /* Keine Funktion, nur O */
    ```
  * Das k√∂nnen wir nun nutzen, um unsere Anforderung umzusetzen:
  * ```typescript
    declare function check<O>(o: O): O extends (...args: any) => infer A ? A : O
    ```
---
###  Type Inference mit Conditional Types 
* Weitere Beispiele
* ```typescript
  // R√ºckgabe-Wert f√ºr eine Funktion ohne Parameter:
  type RetValue<O> = O extends () => infer R ? R : never
  ```
* ```typescript
  // Ermitteln des ersten Arguments einer Funktion:
  type FirstArg<O> = O extends (a: infer A, ...args: any) => any ? A : never
  ```
* Was ist der Unterschied zu diesem Beispiel und warum sollte man das eine oder das andere machen? ü§î
* ```typescript
  type FirstArg<O extends (a: any, ...args: any) => any> = O extends (a: infer A, ...args: any) => any ? A : never
  ```
* Typ eines Arrays ermitteln:
* ```typescript
  type TypeOfArray<A> = A extends (infer A)[] ? A : never

  type T1 = TypeOfArray<string[]> // string
  type T2 = TypeOfArray<string>; // never
  ```
* F√ºr typische Anforderungen gibt es bereits fertige _Utility Typen_, z.B.:
  * [Awaited](https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype): Liefert Typ von Promises zur√ºck
  * [ReturnType](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype): R√ºckgabe-Typ einer Methode
  * [InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype): Typ der Instanz einer Klasse
  

---
### √úbung: Conditional Types

* Erweitere die `validate`-Funktion
  - Wenn der Typ einer Eigenschaft im Original-Objekt eine Funktion ist, soll deren R√ºckgabe-Type (oder null) im `ValidatedObject` auftauchen
  - Fachlicher Hintergrund: beim Validieren des Objektes werden daran enthaltenen Funktionen ausgef√ºhrt und dann deren R√ºckgabetyp validiert.
* ```typescript
  type Person = {
    firstname: string;
    age: number;
    hobbies: () => string[]
  }

  type ValidatedPerson = {
    firstname: string | null;
    age: number | null;
    hobbies: string[] | null; // 'string[]' ist R√ºckgabe-Typ von Person.hobbies
  }
  ```
* Material findest Du in `src/490_uebung_conditional.ts`
* M√∂gliche L√∂sung in `src/490s_uebung_conditional.ts`
---
<!-- -------------------------------------------------------------- -->
<!--    TEMPLATE LITERAL TYPES                                      -->
<!-- -------------------------------------------------------------- -->

## Template Literal Types
<!-- .slide: id="t-template-literale" -->
---
### Hintergrund: Literal Types
<!-- .slide: class="left" -->
* Zur Erinnerung: ein konkreter String kann ein Typ in TypeScript sein.
* Damit k√∂nnen wir zum Beispiele eine Art Aufz√§hlungstyp bauen, um sicherzustellen, dass nur semantisch korrekte Strings
  an einer Stelle verwendet werden:
* ```typescript
  type Direction = "top" | "right" | "bottom" | "left";

  declare function setMargin(d: Direction, size: string): void;

  setMargin("top", "2rem"); // ok
  setMargin("middle", "2rem"); // ERR: Argument of type '"middle"' is not 
                               //      assignable to parameter of type 'Direction'
  ```
- Hier kann die `setMargin`-Funktion als `d` nur die String-Werte `top`, `right`, `bottom`, oder `left` entgegennehmen.
- Der zu setzende Wert (`size`) wird als beliebiger String √ºbergeben.
- Wie k√∂nnen wir sicherstellen, das auch der zweite String nicht beliebig ist, sondern dem Format `Gr√∂√üe + Einheit` enstpricht (`2rem`, `24px`, ...)
---
### Template Literal Types
<!-- .slide: class="left" -->
- Analog zu einem Template String in JavaScript k√∂nnen wir in TypeScript mit einem [Template Literal Type](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) "Regeln" f√ºr String-Typen beschreiben.
- Dazu verwenden statt der Anf√ºhrungszeichen die Backticks (`` ` ``) und k√∂nnen darin wie in JavaScript mit `${...}` Platzhalter definieren.
- In die Platzhalter werden dann erlaubte Werte(mengen) eingesetzt.
- Die Gr√∂√üenanabge f√ºr `setMargin` soll sich aus einer Zahl (`number`) und einer Einheit (`string`) zusammensetzen und k√∂nnte im ersten Schritt so definiert werden:
* ```typescript
  type Size = `${number}${string}`

  declare function setMargin(d: Direction, size: Size): void;

  setMargin("top", "2rem"); // OK
  setMargin("top", "XL"); // ERR
  setMargin("top", "A4"); // ERR
  setMargin("top", "2"); // OK (Leerstring...)
  ```
---
### Template Literal Types
 
* Wie k√∂nnen wir Ausdr√ºcken, dass die Einheit nur `em`, `rem` oder `px` sein darf?  
  * Wir erlauben nicht mehr beliebige String mit `${string}`, sondern schreiben explizit die erlaubten Strings hin:
  * ```typescript
    type Size = `${number}em` | `${number}rem` | `${number}px`

    declare function setMargin(d: Direction, size: Size): void;

    setMargin("top", "2em"); // OK
    setMargin("top", "1.5rem"); // OK
    setMargin("top", "24pt"); // ERR
    setMargin("top", "2"); // ERR
    ```
---
### Template Literal mit Union Types
 
* Der gesehene `Size`-Typ funktioniert, kann bei vielen Auspr√§gungen aber un√ºbersichtlich werden
* Wir k√∂nnen stattdessen f√ºr die Einheit selbst einen Union Typen verwenden, der die erlaubten Einheiten beschreibt
* Wenn ihr einen Union Type in einem Template Literal einsetzt, enth√§lt der neue Typ alle Kombinationen aller enthalten Union Types:
* ```typescript
  type Unit = "em" | "rem" | "px"
  type Size = `${number}${Unit}`
  // oder: 
  // type Size = `${number}${"em" | "rem" | "px"}`

  declare function setMargin(d: Direction, size: Size): void;

  setMargin("top", "2em"); // OK
  setMargin("top", "1.5rem"); // OK
  setMargin("top", "24pt"); // ERR
  setMargin("top", "2"); // ERR
  ```
---
### Template Literal mit Union Types
* Als weiteres Beispiel soll eine Verallgemeinerung von `setMargin` dienen.
* Diese Funktion soll jetzt  `margin` oder `padding` setzen k√∂nnen.
* Die Angabe soll dabei (wie in CSS) als String mit Direction erfolgen.
* Hier k√∂nnen wir zwei Union Types in unser Template Literal einsetzen. 
* ```typescript
  type Spacing = "margin" | "padding";
  type Direction = "top" | "right" | "bottom" | "left";
  type CSSClassNames = `${Spacing}-${Direction}`;

  type Size = `${number}${"em" | "rem" | "px"}`

  declare function setSpacing(c: CSSClassNames, size: Size): void;

  setSpacing("margin-right", "2rem");  // OK
  setSpacing("padding-center", "2rem"); // ERROR
  ```
---
### String Manipulation in Template Literal Types

* Nehmen wir an, wir wollen f√ºr fiktive Events den Namen ihrer `addListener`-Funktion ermitteln
  * Die `addListener`-Funktion soll den Event-Namen in ihrem Namen tragen
  * Das k√∂nnte folgende Regel auf Wert-Ebene sein:
  * ```typescript
    const changeEvent = "change";
    const changeListenerName = "addChangeListener"

    const insertEvent = "insert";
    const insertListenerName = "addInsertListener"
    ```
* Prinzipell k√∂nnten wir daf√ºr folgenden Typen definieren:
* ```typescript
  type ListenerName<E extends string> = `add${E}Listener`;
  ```
* Dann ist allerdings der Event-Name falsch geschrieben (Kleinbuchstabe!):
* ```typescript
  type ChangeListenerName = ListenerName<"change">;
        // ^?  addchangeListener
  const changeListenerName: ChangeListenerName = "addChangeListener"    
        // ERROR: Type '"addChangeListener"' is not assignable to type '"addchangeListener"'
  ```
* Wir m√ºssen also den urspr√ºnglichen String manipulieren
---
### String Manipulation in Template Literal Types
* Um einen String-Typen zu manipulieren, stellt TypeScript [einige Hilfstypen](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types) zur Verf√ºgung:
* `Uppercase`
* ```typescript
  type S = UpperCase<"change"> // "CHANGE"
  ```
* `Lowercase`
* ```typescript
  type S = UpperCase<"CHANGE"> // "change"
  ```
* `Capitalize`
* ```typescript
  type S = Capitalize<"change"> // "Change"
  ```
* `Uncapitalize`
* ```typescript
  type S = Uncapitalize<"Change"> // "change"
  ```  
* Damit k√∂nnen wir unseren Typen nun korrekt ausdr√ºcken!
* ```typescript
  type ListenerName<E extends string> = `add${Capitalize<E>}Listener`;

  type ChangeListenerName = ListenerName<"change">;
        // ^?  addChangeListener üòä

  const changeListenerName: ChangeListenerName = "addChangeListener" ‚úÖ
  ```
---
### √úbung: Template Literal Types
<!-- .slide: class="left" -->
* Erweitere den `Spacing` bzw. `CSSClassnames`-Typen, so dass er einem (mehr oder weniger) kompletten, g√ºltigen CSS-Ausdruck entspricht:
  * `setSpacing("margin-right: 2rem")` ‚úÖ
  * `setSpacing("margin-middle: 2rem")` ‚ùå
  * `setSpacing("padding-top: 24pt")` ‚ùå
* Schreibe einen Typen, der ein `Spacing` und eine `Direction` 
  entgegennimmt, und einen String ausdr√ºckt, der die beiden Typen als PascalCase enth√§lt
  (`"margin"`,`"top"`) => `"MarginTop"`
* In `src/590_template_literal_uebung.ts` findest Du das Material mit Hinweisen.
* M√∂gliche L√∂sung in `src/590s_template_literal_uebung.ts`  

---
### √úbung 2 (muss sp√§ter)
<!-- .slide: data-visibility="hidden" -->  
* Etwas trickreich:
  * Schreibe einen `SwapCapitalize`-Typen, der einen `string` entgegennimmt 
    - Wenn der String mit einem Gro√übuchstaben anf√§ngt, soll der String mit Kleinbuchstaben zur√ºckgeliefert werden, sonst umgekehrt
  * ```typescript
    type SwapCapitalize<S extends string> = ???;

    type A = SwapCapitalize<"addListener">;
      // ^?  "AddListener"

    type B = SwapCapitalize<"AddListener">;
      // ^?  "addListener"
    ```
---
### L√∂sung: Template Literal Types (muss sp√§ter)
<!-- .slide: data-visibility="hidden" -->
<!-- .slide: class="left" -->
* CSS Ausdruck:
* ```typescript
  type CSSExpression = `${CSSClassNames}:${Size}`
  function setSpacing(c: CSSExpression) {}
  setSpacing("margin-right: 2rem"); // OK
  setSpacing("margin-middle: 2rem"); // ERR
  setSpacing("padding-top: 24pt"); // ERR
  ```
 
* Swap
  * ```typescript
    type Swap<S extends string> = S extends Capitalize<S> ? Uncapitalize<S> : Capitalize<S>

    type A = Swap<"addListener">;
      // ^?  "AddListener"

    type B = Swap<"AddListener">;
      // ^?  "addListener"  
    ```

---
### Keys mit Template Literal Types umbenennen
<!-- .slide: id="t-template-literale-remapping" -->

- Wenn ihr einen _Key_ in einem Mapped Type umbenennen wollt, k√∂nnt ihr das mit einem Template Literal Type tun
* Fachliches Beispiel:
  - Die schon gesehene `createSetter`-Funktion liefert Setter-Funktionen f√ºr ein ganzes Objekt (`anObject`) zur√ºck
  - Dazu gibt `createSetter` ein Objekt zur√ºck, in dem f√ºr jedes Feld in `anObject` eine Setter-Funktion enthalten ist
  - Die Keys im `setter`-Objekt sollen nun allerdings `setFieldname` und nicht mehr `fieldname` heissen:
  * ```typescript
    function createSetter(observedObject) { /* ... */ }
    const setters = createSetter( { firstname: "klaus", age: 32} ) ;
           // setters: { setFirstname(newValue) { /* ... */ }, setAge(newValue) { /* ... */ } }
    // √Ñndern des Vornamens:
    setters.setFirstname("Moni");
    ```
* üëâ Der zur√ºckgelieferte Typ muss also die Keys aus dem `observedObject` umbenennen.
  * Wir brauchen konzeptionell also so etwas:
  * ```typescript
    type SetterObject<O extends object> = {
      [Key in keyof O]: (newValue: O[K]) => void;
      // ^-- Hier muss Key umbenannt werden in `set${Capitalize<Key>}`
    }
    ```
---
### Keys mit Template Literal Types umbenennen

* Grunds√§tzlich k√∂nnen bei Mapped Types die Keys umbenannt werden
* Zur Erinnerung: `keyof` liefert eine Liste von _Typen_ zur√ºck (auch wenn diese meist wie "normale" Strings aussehen):
* ```typescript
  type KeysInPerson = keyof Person; // "firstname" | "age"
                                          ^------------^---- Typen! Keine Werte! Keine Strings!
  ```
* Um einem Key einen neuen Namen zu √§ndern, m√ºssen wir also dessen _Typ_ ver√§ndern
* Das kann man mit einem Type Cast (`as`) machen
* In Kombination mit einem Template Listeral Type zum Beispiel so
  * ```typescript
    // Achtung! Beispiel funktioniert so noch NICHT
    type SetterObject<O extends object> = {
      [Key in keyof O as `set${Capitalize<Key>}`]: (newValue: O[K]) => void;
    }
    ```
* Das funktioniert aber so noch nicht!
* Es gibt Compile-Fehler:
  * Im Template Literal d√ºrfen wir nur string, boolean, null etc. angeben aber kein `Symbol`
  * `Capitalize` erwartet sogar nur einen `string`

---
###  Keys mit Template Literal Types umbenennen
* Ein Template Literal Type kann nur mit dem Typ `string | number | bigint | boolean | null | undefined` arbeiten
* Der `Capitalize` ist noch restriktiver: dieser kann nur mit einem `string` verwendet werden
* Ein Eintrag in `keyof` kann neben `string` aber auch `number` oder `symbol` sein, weil diese als Keys an Objekten verwendet werden k√∂nnen
* ```typescript
  const person = {
    firstname: "Klaus",
    2: "zwei",
    [Symbol()]: "geheim",
  };
  ```
* Wir m√ºssen also die Typen aus `keyof` rausfiltern, die keine Strings sind
* Wie k√∂nnten wir das mit einem Union Type und `never` machen? ü§î
* ```typescript
  type StringKeysOf<O extends object, K = keyof O> = K extends string ? K : never
  ```
* Es gibt eine andere Alternative...
---
### Exkurs: Intersection und Union Types
<!-- .slide: id="t-intersection-und-union-types" -->

* Ein _Intersection Type_ stellt eine "√úberschneidung" aus zwei Typen dar.
* ```typescript
    type Person = { firstname: string; age: number }
    type Address = { city: string; street: string }

    type PersonWithAddress = Person & Address; // Intersection type
  ```
* Da der Typ `PersonWithAddress` die Gemeinsamkeiten von `Person` und `Address` darstellt, m√ºssen auch alle Eigenschaften beim Instaniieren des Typs angegeben werden:
* ```typescript
  const p: PersonWithAddress = { 
    firstname: "Klaus", age: 32,
    city: "Hamburg", street: "Reeperbahn"
   };
  ```
* Der Verwender dieses Typs kann sich dann aber darauf verlassen, alle Eigenschaften von `Person` _und_ `Address` zu haben:
* ```typescript
  function sendLetter(p: PersonWithAddress) {
    p.firstname.toUpperCase(); // OK
    p.city.toUpperCase(); // OK
  }
  ```
* Bei einem _Union Typen_ ist es genau andersrum.
---
### Exkurs: Intersection und Union Types
* Ein _Union Type_ enth√§lt die Eigenschaften aus dem einen _oder_ dem anderen Typen:
* ```typescript
  type Person = { firstname: string; age: number }
  type Animal = { name: string; species: string }

  type PersonOrAnimal = Person | Animal;
  ```
* Um ein `PersonOrAnimal` zu erzeugen, reicht es, die Eigenschaften von `Person` _oder_ `Animal` anzugeben:
* ```typescript
  type klaus: PersonOrAnimal = { firstname: "Klaus", age: 32 };
  ```
* Der Verwender kann sich dann nicht sicher sein, welche Eigenschaften er hat (`Person`, `Animal` oder beide), und muss einen entsprechenden _Type Guard_ pr√ºfen, welche Auspr√§gung vorliet:
* ```typescript
  function sayHello(p: PersonOrAnimal) {

    // p ist hier Person | Animal

    p.firstname.toUpperCase(); // ERROR: Property 'firstname' does not exist on type 'PersonOrAnimal'.
                               //         Property 'firstname' does not exist on type 'Animal'

    if ("firstname" in p) {

      // p ist hier nun Person  
      p.firstname.toUpperCase(); // OK
        
    }                               
  }

  ```
---
### Exkurs: Intersection und Union Types
* Was passiert nun, wenn beide Typen kombiniert werden? üôÄ
* ```typescript
  type ColorsOfFrance = "blue" | "white" | "red"
  type ColorsOfSwiss = "red" | "white";

  type ColorsOfSwissAndFrance = ColorsOfSwiss & ColorsOfFrance
         // ^? ???
  ```
* Richtig ist die gemeinsame _Schnittmenge_ der Farben:
  * ```typescript
    type ColorsOfSwissAndFrance = ColorsOfSwiss & ColorsOfFrance
            // ^? "red" | "white"
    ```
  * Wenn es nicht die Schnittmenge w√§re, sondern die Menge aller Auspr√§gungen aller Union Typen (`"blue" | "white" | "red"`), k√∂nnten wir einen Typen 
erzeugen, der hinterher nicht mehr an `ColorsOfSwiss` zuweisbar w√§re:   
  * ```typescript
  type AllColorsOfSwissAndFrance = "blue" | "white" | "red";
  const c: AllColorsOfSwissAndFrance = "blue";
  const f: ColorsOfFrance = c; // OK
  const s: ColorsOfSwiss = c; // ERR Type '"blue"' is not assignable to type 'ColorsOfSwiss'
  ```
---
### Exkurs: Intersection und Union Types
* Was passiert, wenn diese beide Typen kombiniert werden? üôÄ
* ```typescript
  type StringOrNum = string | number;
  type StringOrBoolean = string | boolean
  type StringOrNumAndStringOrBoolean = StringOrNum & StringOrBoolean
         // ^? ???
  ```
  * Ebenfalls die Schnittmenge, gleicher Fall wie vorher nur mit anderen Typen:
* ```typescript
  type StringOrNumAndString = StringOrNum & string
        // ^? string
  type StringOrNumAndStringOrBoolean = StringOrNum & StringOrBoolean
        // ^? string
```
* Und nun die Keys aus unserem `Person`-Objekt:
* ```typescript
  type Person = { firstname: string, 2: [Symbol()]: "geheim" }

  type KeysOfPerson = keyof Person; 
         
  type KeysOfPersonAndString = KeysOfPerson & string
         // ^? ???
  ```
  * Ebenfalls selbes Prinzip, nur das der Union Typ diesmal aus `keyof` kommt:
    * ```typescript
      type KeysOfPerson = keyof Person; 
        // ^?  "firstname" | 2 | symbol;

      type KeysOfPersonAndString = KeysOfPerson & string
        // ^? "firstname"
      ```


---
###  Keys mit Template Literal Types umbenennen
* Alle Keys die nicht vom Typ `string` sind, werden damit rausgefiltert und sind im neuen Objekt nicht vorhanden.
* ```typescript
  type SetterObject<O extends object> = {
    [Key in keyof O & string as `set${Capitalize<Key>}`]: (newValue: O[Key]) => void;
  }
  ```
  
* ```typescript
  declare function createSetter<O extends object>(o: O): SetterObject<O>;

  const setters = createSetter( { firstname: "klaus", age: 32} ) ;
  // √Ñndern des Vornamens:
  setters.setFirstname("Moni"); // ‚úÖ
  setters.firstname("Moni"); // ‚ùå
  ```
* Ob das Entfernen der nicht-String-Keys korrekt ist, ist eine fachliche Frage
  * Was k√∂nnten wir stattdessen tun? ü§î 

---
### √úbung: Template Literal Types

* Modifiziere den Typen f√ºr die `validate`-Funktion
*  In dem Objekt mit den `validator`-Funktionen sollen die Namen der Keys jeweils mit `validate` anfangen:
  * `lastname` => `validateLastname`
  * `age` => `setAge`
* **Optional**:
  * In dem validate-Objekt sollen keine validator-Funktionen erlaubt sein, wenn der Eintrag im 
  zu validierenden Objekt eine void-Funktion ist ü§Ø
  * ```typescript
    const person = { age: 32, sayHello: () { /* void-Funktion! */ } };
    // im validator-Objekt muss ein Eintrag f√ºr `age` (`validateAge`) vorhanden sein,
    // aber KEIN Eintrag f√ºr `sayHello`
    ```
* Hinweise und Vorlagen findest Du in `690_template_literal_remapping_uebung.ts`
* M√∂gliche L√∂sungen findest Du in `690s_template_literal_remapping_uebung.ts`  


---
### Ausblick: Conditional Types mit Template Literal Types
<!-- .slide: id="t-template-literale-conditional-types" -->

<!-- .slide: class="left" -->
* Mit einem Conditional Type k√∂nnen wir pr√ºfen, on ein Typ einem (String-)Muster entspricht
* ```typescript
  type IsAddListenerName<S> = S extends `add${string}Listener` ? true : false;

  type IsChangeListener = IsAddListenerName<"addChangeListener">; // true
  type IsUpdateListener = IsAddListenerName<"updateListener">; // false
  ```
* Das `${string}` matched auf einen beliebigen String (gleiches geht mit `${boolean}` oder `${number}`)
* Es k√∂nnen auch Platzhalter √ºbergeben werden:
* ```typescript
  type IsAddListenerForEventName<S, E> = S extends `add${Capitalize<E>}Listener` ? true : false;

  type IsChangeListener = IsAddListenerForEventName<"addChangeListener", "change">; // "true"
  type IsChangeOrUpdateListener = IsAddListenerForEventName<"addChangeListener", "change" | "update">; // "true"
  type IsUpdateListener = IsAddListenerForEventName<"addChangeListener", "update">; // "false"
  ```
* Nat√ºrlich geht das auch mit Constraints:
* ```typescript
  type Event = "change" | "update";
  type IsAddListenerForEventName<S extends string, E extends Event> = 
                                     S extends `add${Capitalize<E>}Listener` ? true : false;
  // Verwendung wie oben
  ```
* ...oder mit Defaults:
* ```typescript
  type Event = "change" | "update";
  type IsAddListenerForEventName<S extends string, E extends Event = "change"> = 
                                     S extends `add${Capitalize<E>}Listener` ? true : false;
  type IsChangeListener = IsAddListenerForEventName<"addChangeListener">; // "true"
  type IsUpdateListener = IsAddListenerForEventName<"addUpdateListener">; // "false"
    ```

---
### Template Literal Types mit infer
<!-- .slide: class="left" -->
* Mit dem `infer` Schl√ºsselwort k√∂nnt ihr Euch den "eingesetzten" Teil in eine Typ-Variable extrahieren lassen
  * Analog zu dem, was wir zuvor schon bei den Conditional Types gesehen haben:
* ```typescript
  type GetEventNameFromListener<S extends string> = S extends `add${infer EN}Listener` ? Uncapitalize<EN> : never;
    
  type ChangeEvent = GetEventNameFromListener<"addChangeListener">; // "change"
  type NoChangeEvent = GetEventNameFromListener<"addChangeHandler">; // never
  ```
* Auch die Platzhalter lassen sich mit Constraints kombinieren:
* ```typescript
  type GetEventNameFromListener<S extends string> 
         = S extends `add${infer EN extends Event}Listener` ? Uncapitalize<EN> : never;

  type ChangeEvent = GetEventNameFromListener<"addChangeListener">; // "change"
  type NoEvent = GetEventNameFromListener<"addInsertListener">; // never
  type NoListener = GetEventNameFromListener<"addChangeHandler">; // never
  ```
* Damit lassen sich sehr m√§chtige Dinge bauen, z.B. [SQL "Datenbanken"](https://github.com/codemix/ts-sql) ü§Ø 
---
### √úbung Template Literal Types mit infer
* Ein Typ `S` besteht aus zwei W√∂rtern, die mit Bindestrich getrennt sind (z.B. `"margin-left"` oder `"padding-right"`)
* Baue einen Typen, der den Inhalt von `S` in camelCase-Notation zur√ºckliefert ("`marginLeft"` oder `"paddingRight"`)
* Wenn der √ºbergebene Typ nicht dem Muster (`string1-string2`) entspricht, liefer den Typen unver√§ndert zur√ºck oder gib `never` zur√ºck
* Beispiel
  * ```typescript
    type CamelCase<S extends S> = /* ... */
    
    const marginLeft:CamelCase<"margin-left"> = "marginLeft"; ‚úÖ
    const paddingRight:CamelCase<"padding-right"> = "paddingRight"; ‚úÖ
    const paddingTop:CamelCase<"paddingTop"> = "paddingTop"; ‚úÖ // (alternativ: never)
    ```
* Erweiterung 1: Kannst Du den Typen so bauen, dass er aus beliebig vielen W√∂rtern camelCase erzeugt?
* ```typescript
    const background:CamelCase<"background"> = "background"; ‚úÖ
    const marginLeft:CamelCase<"margin-left"> = "marginLeft"; ‚úÖ
    const maxPageWidth:CamelCase<"max-page-width"> = "maxPageWidth"; ‚úÖ
  ```
* Erweiterung 2: Kannst Du den Typen so erweitern, dass man das Trennzeichen festlegen kann?  
* ```typescript
  const marginLeft:CamelCase<"margin-left", "-"> = "marginLeft"; ‚úÖ
  const helloWorld:CamelCase<"hello world", " "> = "helloWorld"; ‚úÖ
  ```
---
### L√∂sungen
<!-- .slide: class="left" -->
* Zwei W√∂rter, mit Bindestrich getrennt:
  * ```typescript
    type ToCamelCase<S> = S extends `${infer left}-${infer right}`
      ? `${left}${Capitalize<right>}`
      : S;
    ```
* "Rekursiv", beliebige Anzahl an W√∂rtern mit Bindestrich getrennt: 
  * ```typescript
    type ToCamelCase<S> = S extends `${infer left}-${infer right}`
      ? ToCamelCase<`${left}${Capitalize<right>}`>
      : S;
    ```
* "Rekursiv" und mit variablem Trennzeichen:
  * ```typescript
    type ToCamelCase2<
      S,
      D extends string = "-" // D ist das Trennzeichen, per Default auf "-" vorbelegt
    > = S extends `${infer left}${D}${infer right}`
      ? ToCamelCase<`${left}${Capitalize<right>}`>
      : S;
    ```


          </textarea>
        </section>
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit TypeScript!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            Mail:
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            Web:
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            <a
              href="https://www.linkedin.com/in/nils-hartmann-2a5738252/"
              target="_blank"
              >LinkedIn
            </a>
          </p>
          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            Mastodon:
            <a href="https://norden.social/@nilshartmann" target="_blank"
              >@nilshartmann@norden.social
            </a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
