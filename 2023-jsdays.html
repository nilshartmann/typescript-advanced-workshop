<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>TypeScript Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="slides/revealjs/reveal.js/dist/theme/solarized.css"
    />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link
      rel="stylesheet"
      href="slides/revealjs/highlight-js-github-theme.css"
    />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal" data-beta="true">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>TypeScript Advanced</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg"
                >https://github.com/nilshartmann/typescript-advanced-workshop</span
              >
            </p>
          </div>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2023-jsdays.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://nilshartmann.github.io/typescript-advanced-workshop/2023-jsdays.html"
                >
                  https://nilshartmann.github.io/typescript-advanced-workshop/2023-jsdays.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p style="margin-top: 2rem">
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>
          <p></p>
          <p style="margin-top: 5rem">
            Java | JavaScript, TypeScript | React | GraphQL
          </p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- Das Typsystem von TypeScript hilft uns in der t√§glichen Arbeit, typische Programmierfehler zu vermeiden. 
          Dazu schreiben wir Typ-Angaben zum Beispiel an Variablen oder Funktionsargumente. 
          Die Beschreibung der Typen selbst ist aber gar nicht immer so trivial. 
          Durch das dynamische Typsystem von JavaScript kann eine Funktion beispielsweise ein beliebiges Objekt entgegennehmen und in 
          einer abgeleiteten Form zur√ºckgeben. 
          F√ºr diese Herausforderung bringt TypeScript eine Art Meta-Sprache mit, mit der sich Typen an Hand verschiedener 
          Regeln programmieren lassen. Damit lassen sich auch f√ºr komplexe Anwendungsf√§lle, zum Beispiel APIs von Bibliotheken, 
          Typen beschreiben, so dass Nutzerinnen und Nutzer der Funktionen vollst√§ndige Typsicherheit haben - 
          ohne selbst Typdefinitionen schreiben zu m√ºssen.


        In diesem Workshop sehen wir uns diese Meta-Sprache an Hand von Beispielen in der Praxis an. 
        Wir werden unter anderem Mapped Types, Utility Types und Conditional Types untersuchen und sehen, 
        f√ºr welche Anwendungsf√§lle sie jeweils geeignet sind.
         Dazu machen wir nat√ºrlich auch √úbungen, so dass Du das Gelernte direkt Hands-on ausprobieren kannst. 
         F√ºr den Workshop solltest Du grunds√§tzliche TypeScript-Kenntnisse mitbringen. 
        
        https://javascript-days.de/javascript/advanced-typescript/
        -->

        <!-- ######################################################  -->
        <section>
          <h2>Advanced TypeScript</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Hinweis!

* Wir konzentrieren uns hier nur auf die Typ-Ebene
* Die gezeigten Beispiele kommen daher ohne Implementierung aus
* Ich m√∂chte Euch zeigen, wie ihr komplexe Typ-Definitionen schreiben k√∂nnt, von denen Verwender Eurer APIs dann profitieren
  * Die APIs kann man nutzen, ohne viel TypeScript Typen schreiben zu m√ºssen
  * Verwendung der APIs ist aber trotzdem typsicher
          </textarea>
        </section>

        <!-- <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre
            class="fragment"
          ><code class="typescript line-numbers" contenteditable data-trim>
  // unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Pr√ºfung
  function loadData(): unknown { return "" // ok }
  let b = loadData(); 
  b.toUpperCase(); // ERROR
  if (typeof b === "string") {
    // b ist jetzt string (typeof ist Laufzeitpr√ºfung!)
    b.toUpperCase(); // OK
  }
              </code></pre>
        </section> -->

        <section>
          <h2>Union Types</h2>
          <p class="todo">evtl. raus f√ºr JS Days</p>
          <p>Variablen, Parameter etc. k√∂nnen mehr als einen Typ annehmen:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) { 

  console.log(obj.title); // ERR: Property 'title' does not 
                          // exist on type 'Person | Movie'
 
  if ("title" in obj) { // Abfrage ist ein "Type Guard"
    // obj ist Movie hier, title ist definiert
    console.log(obj.title);
  } else {
    // obj ist Person hier: name ist definiert
    console.log(obj.name);
  }
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR
    
          </code></pre>
        </section>
        <section>
          <h2>Type Guards</h2>
          <p class="todo">evtl. raus f√ºr JS Days</p>
          <p>Durch einen Type Guard k√∂nnen Typen "eingeengt" werden</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das √ºbergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
  return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) { 
  if (isMovie(obj)) {
    // movie
  }
}
    
          </code></pre>
        </section>
        <section>
          <h2>Type Assertions</h2>
          <p class="todo">evtl. raus f√ºr JS Days</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das √ºbergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is  Movie {
  if ("title" in candidate) {
    return;
  }
  throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) { 
  assertPersonIsMovie(hopefullyAMovie)
  // hopefullyAMovie ist jetzt Movie
  hopefullyAMovie.title; // OK
}
    
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Type Aliase
* Mit dem Schl√ºsselwort [`type`](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases) wird ein __Type Alias__ erzeugt.
* Ein Type Alias ist nur ein (anderer) Name f√ºr einen Typen
* Man kann immer entweder einen Type Alias oder einen kompletten Typen hinschreiben
* Beispiele:
  * ```typescript
    declare function createPerson(firstname: string, address: {city: string} ): 
                                        { firstname: string, address: { city: string } };

    ```
  * ist identisch mit:  
  * ```typescript
    type Address = {
      city: string;
    }
    type Person = {
      firstname: string
      address: { city: string }
    }
    declare function createPerson(firstname: string, address: Address ): Person;
  ```

  * ...und auch das ist identisch:
  * ```typescript
    type Address = {
      city: string;
    }
    type Person = {
      firstname: string
      address: Address
    }
    declare function createPerson(firstname: string, address: Address ): Person;
  ```
* Man verwendet immer das, was am besten passt
---
### Index Access
* Mit dem Index Operator kannst Du in JavaScript auf _Werte_ aus einem _Objekt_ zugreifen:
* ```typescript
  const person = {
    firstname: "Klaus",
    address: { city: "Hamburg", street: Reeperbahn }
  }

  const address = person["address"];
  ```
* Etwas √§hnliches kannst Du auch mit _Typen_ machen, wenn du den _Typ_ eines Properties ben√∂tigst:
* ```typescript
  type Person = {
    firstname: string
    address: { city: string }
  }

  type Address = Person["address"]
  ```
* Das kann hilfreich sein, wenn Du einen Typen hast, den Du nicht selbst beschrieben hast. 
  * Zum Beispiel wenn der Typ aus einer Bibliothek stammt oder von einem Code Generator erzeugt wurde.

---
### Index Access #2
* Wenn Du den Typen eines Arrays ben√∂tigst, kannst Du statt eines Property-Namens `[number]` hinschreiben:
* ```typescript
  type Person = {
    contacts: [
      {
        email: string;
        phone: string;
      }
    ];
  };

  type Contacts = Person["contacts"];        // Array<{ email: string, phone: string }>
  type Contact = Person["contacts"][number]; //       { email: string, phone: string }

  declare function addContact(c: Contact): void;

  addContact({email: "nils@nilshartmann.net", phone: "..."})
  ```

---
### keyof

* [`keyof`](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) liefert einen Union Typen zur√ºck, der alle Keys eines Objektes enth√§lt
* ```typescript
  type Person = {
    firstname: string;
    lastname: string;
  }
  type PersonKeys = keyof Person; // "firstname" | "lastname"

  ```
* Damit kann man zum Beispiel erzwingen, das ein Funktionsparameter nur g√ºltige
  Keys eines Objekts aufnehmen kann:
* ```typescript
  declare function logPropertyOfPerson(propName: keyof Person): void;

  logPropertyOfPerson("firstname"); // OK
  logPropertyOfPerson("age") // ERR: Argument of type '"age"' is not 
                             // assignable to parameter of type 'keyof Person'

  ```
---
### String Literal Types
* Mit einem [String Literal Type]() kannst Du einen Typen definieren, der einen konkreten String darstellt 
* ```typescript
  // Beispiel:             
  type Answer = "Yes" | "No" | "I_dont_care";

  const a1:Answer = "Yes"; // OK
  const a2:View = "Maybe" // FEHLER
  ```
* ```typescript
  function fillIn(a: Answer) {
    if (a === "Yes") { ... } // ok
    if (a === "Maybe") { ... } // error: immer false
  }

  fillIn("I_dont_care"); //OK
  fillIn("Maybe"); // ERROR
  ```
---
### Der typeof-Operator

* Der `typeof`-Operator in JavaScript liefert den _Wert_ einer Variablen zur Laufzeit zur√ºck.
* Mit dem [`typeof`-Operator von TypeScript](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#handbook-content) kann der Typ eines Werts auf Typ-Ebene ermittelt werden.
  * Im Grunde das, was die IDE tut, wenn ihr mit der Maus √ºber einen Variable fahrt
* ```typescript
  const languages = {
    de: "DE",
    en: "EN"
  }

  type TLanguages = typeof languages;          // TLanguages ist TYPE, languages ist WERT
        // { de: string; en: string; }

  export declare function translateMessage(msg: string, lang: keyof TLanguages): string;

  // oder:
  type TLanguageKeys = keyof typeof languages;
  export declare function translateMessage(msg: string, lang: TLanguageKeys): string;
  ```
* Das geht f√ºr alle m√∂glichen Dinge, auch f√ºr Funktionen:
* ```typescript
  declare function sayHello(name: string): string | null;
  
  type Fn = typeof sayHello;
       // (name: string) => string | null
  ```
  
---
### Typen anzeigen
* In der Regel k√∂nnt ihr Euch in Eurem Editor oder Eurer IDE den Typen einer Variable anzeigen lassen, in dem ihr mit der Maus dar√ºber fahrt  
* Im [TypeScript Playground](https://www.typescriptlang.org/play) k√∂nnt ihr mit `// ?^` unter einer Variablen Euch deren Typen anzeigen lassen
* ![Tooltip](./slides/images/screenshot-type-tooltip.png)
* F√ºr VS Code gibt es dazu eine [Extension](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-twoslash-queries)

---
### Generics
* Mit `any` k√∂nnen wir Funktionen beschreiben, die alle m√∂glichen Typen entgegennehmen
  und/oder zur√ºckliefern
  * ```typescript
    declare function validate(obj: any): any
    ```
* Was machen wir aber, wenn wir den √ºbergebenen Typen (f√ºr `obj`) an anderer Stelle ben√∂tigen?
  * Zum Beispiel, um sicherzustellen, dass der R√ºckgabe-Typ identisch ist?
* ```typescript
  const p = validate("hallo"); // p soll string sein (ist: any üòî)
  const n = validate(123); // n soll number sein (ist: any üòî)
  ```

---
### Generics
* F√ºr Funktionen (und Typen) k√∂nnen **Typ Variablen** definiert werden
* Fast wie Funktionsparameter, nur dass keine __Werte__, sondern __Typen__ angegeben werden
* Die Typ Variable wird deklariert (`<VariablenName>`) und kann dann in der gesamten Funktionssignatur bzw. Typ-Definition verwendet werden
* Beispiele:
  * ```typescript
    // "O" ist Typ Variable
    declare function validate<O>(o: O): O
    const p = validate("hallo"); // p jetzt string üòä
    const n = validate(123); // n jetzt number üòä
    ```
* Mehr Beispiele:    
  * ```typescript
      // Idee liefert den √ºbergebenen Wert zur√ºck, oder
      // null falls dieser ung√ºltig ist (was auch immer "ung√ºltig" hier bedeutet)  
      declare function validate<O>(o: O): O | null
    ```
  * ```typescript
      // Ein Typ, der entweder eine Liste von Dingen ist oder null
      // (fachlich bescheuertes Beispiel, bessere Beispiele folgen...)
      type ListOrNull<O> = Array<O> | null;
    ```
---
### Generics
* Beim Verwenden in einer Funktion wird der __Typ__ entweder vom √ºbergebenen __Wert__ abgeleitet:
* ```typescript
  declare function validate<O>(o: O): O | null
  const x = validate("Hallo"); // O ist string, x ist string | null
  const y = validate(7); // O ist number, y ist number | null
  ```
* ...oder der Typ wird explizit angegeben. Dann muss der __Wert__ dem angegebenen __Typen__ entsprechen:
* ```typescript
  validate<string>("Hallo"); // O ist string, Argument ist string: Alles OK!
  validate<string>(7); // O ist string, Argument ist number:
                       // ERR: Argument of type 'number' is not assignable to parameter of type 'string'
  ```
---
### Generics: Default-Werte
* Analog zu "normalen" Funktionsargumenten, k√∂nnen auch bei Generics Default**typen** angegeben werden
* Wie bei Funktionsargumenten kann auch nur der letzte bzw. die letzten Argumente Default-Typen haben
* ```typescript
  declare function validate<O, R = string>(o: O): O | R

  validate(7); // R√ºckgabeTyp: number | string 
  validate<number>(7); // R√ºckgabeTyp: number | string 
  validate<number, null>(7); // R√ºckgabeTyp: number | null
  validate<number, boolean>(7); // R√ºckgabeTyp: number | boolean
  ```
* ```typescript
  type Tuple<X, Y = string> = [X, Y];

  type TupleOfNumberAndStrings = Tuple<number>; // [number, string]
  type TupleOfStringAndBoolean = Tuple<string, boolean>; // [string, boolean]
  ```
* Wie bei Funktionsargumenten, k√∂nnen auch Typ Variablen an andere Typen weitergegeben werden:
* ```typescript
  type ReactUseStateTuple<V> = Tuple<V, (newValue: V) => void>;
         // [ V, function(a: V): void ]
  ```

---
### Generic: Constraints   
* Wie bei "normalen" Argumente, k√∂nnen die Typ-Argumente Einschr√§nkungen haben:
* Die Einschr√§nkungen werden mnit `extends` definiert
  * Der √úbergenene Typ muss dann derselbe oder ein erweiterter sein:
* ```typescript
  declare function validateObject<O extends object>(o: O): O | null;

  validateObject({name: "Klaus"}); // OK
  validateObject({name: "Klaus"}); // ERR: Argument of type 'string' is not 
                                   // assignable to parameter of type 'object'

  ```
* ```typescript
  type Person = { firstname: string | null };
  declare function getOrDefault<P extends Person>(p: P): P;

  getOrDefault( { } ); // ERR: Property 'firstname' is missing in type '{}' 
                       // but required in type 'Person'
  ```
---
### Generics mit Union Typen  

* Wenn man einen Union Type als Constraint angibt, muss der √ºbergebene Typ einem
  der im Union-Typen enthaltenen Typen entsprechen:  
* ```typescript
  type Color = "red" | "blue" | "green";
  declare function bgColor<C extends Color> (c: Color): { backgroundColor: C };

  bgColor("red"); // OK
  bgColor("white"); // Argument of type '"white"' is not 
                    // assignable to parameter of type 'Color'
  ```
* ```typescript
  type ListOfStringsOrBooleans<X extends string|boolean> = Array<X>
  const c1: ListOfStringsOrBooleans<string> = ["a"]; // Ok
  const c2: ListOfStringsOrBooleans<boolean> = [true]; // Ok
  const c3: ListOfStringsOrBooleans = [true, "jo!"]; // Ok

  const c4: ListOfStringsOrBooleans<number> = [4]; // ERR Type 'number' does not satisfy 
                                                   // the constraint 'string | boolean'

  declare function validateNumberOrString<O extends string|number>(o: O): O | null    
  ```

---
### √úbung Generics
* Beschreibe eine Typsichere `createSetter`-Funktion. Die Funktion soll eine fiktive Setter-Funktion f√ºr ein Property eines
beliebigen Objektes zur√ºckliefern.
  * Fachliche Idee: in der Setter-Funktion k√∂nnen z.B. √úberpr√ºfungen durchgef√ºhrt werden oder die Setter-Funktion k√∂nnte den Wert in eine DB schreiben o.√§.
* Die Funktion soll zwei Parameter haben:
  1. Ein beliebiges Objekt (`someObject`), 2. Den Namen eines Keys aus dem Objekt (`aKey`)
* Der R√ºckgabe-Typ soll eine Funktion sein, die ihrerseits ein Argument hat, das vom Typ des Properties aus dem √ºbergebenen
  Objekt (`someObject`) ist, so dass diese Funktion aufgerufen werden kann, um den Wert des Objektes zu setzen. 
* In JavaScript s√§he das so aus:
  * ```javascript
    function createSetter(someObject, aKey) { /* ... */ } 

    const ageSetter = createSetter({firstname: "Klaus", age: 32}, "firstname");
    ageSetter(33);
    ```
* In TypeScript sollten dann folgende Beispiele funktionieren bzw. einen Fehler ausl√∂sen:
* ```typescript
  const person = { firstname: "Klaus", age: 32 }

  createSetter(person, "firstname")("newFirstName"); // OK
  createSetter(person, "xxx")("newFirstName"); // Argument of type '"xxx"' is not assignable to parameter of type '"firstname" | "age"
  createSetter(person, "age")(33); // OK
  createSetter(person, "age")("33"); // ERR // Argument of type 'string' is not assignable to parameter of type 'number'
  createSetter("Klaus", "klaus"); // Argument of type 'string' is not assignable to parameter of type 'object'
  ```
---
### M√∂gliche L√∂sungen
<!-- .slide: class="left" -->
* ```typescript
  declare function createSetter<O extends object, K extends keyof O>(
    someObject: O,
    aKey: K
  ): (newValue: O[K]) => void;
  ```
* ```typescript
  type SetterFn<Value> = (newValue: Value) => void

  declare function createSetter<O extends object, K extends keyof O>(
    someObject: O,
    aKey: K
  ): SetterFn<O[K]>
  ```
* ```typescript
  type SetterFn<O extends object, K extends keyof O> = (newValue: O[K]) => void;

  declare function createSetter<O extends object, K extends keyof O>(
      someObject: O,
      aKey: K
  ): SetterFn<O, K>  
  ```
---
### Mapped Types
* Mit einem [Mapped Type](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) kannst Du aus einem bestehenden TypeScript Typen einen anderen erzeugen.
* Du kannst damit Logik, die in JavaScript auf Werte-Ebene funktioniert auf Typ-Ebene nachbauen
* Dazu ein Beispiel: eine Funktion, die jedes Feld eines Objekts validiert und ein neues Objekt mit dem Validierungsergebnis zur√ºckliefert:
* ```javascript
  function validateField(value) {
    // Validierungslogik...
    return true; // oder false
  }

  function validateObject(object) {
    if (object == null || typeof object !== "object") {
      throw new Error("invalid type");
    }
    const result = {};
    Object.keys(object).forEach(k => { 
      result[k] = validateField(object[k]);
    });
    return result;
  }
  ```
* Die Funktion nimmt ein beliebiges Objekt entgegen und liefert ein neues Objekt zur√ºck:
  * in diesem sind dieselben Keys wie im Ausgangsobjekt vorhanden
  * Die Werte sind aber in diesem Fall jeweils `true` oder `false` (je nachdem, was die fiktive
  `validateField`-Funktion zur√ºckgegeben hat.)

---
### Mapped Types
* Eine - unzureichende - Typ-Definition f√ºr diese Funktion k√∂nnte so aussehen:
* ```typescript
  declare function validateObject(o: object): object;

  const result = validateObject( { firstname: "Klaus", age: 32} );
    //  ^? result: object

  ```
* So k√§me ein _beliebiges_ oder _allgemeines_ Objekt zur√ºck. Wir wissen aber eigentlich genauer, wie das Objekt aussieht, das zur√ºckgeliefert wird.
* ```typescript
  const result = validateObject( { firstname: "Klaus", age: 32} );
    //  pr√§ziser R√ºckgabetype w√§re: { firstname: boolean, age: boolean }

  ```
* Mit einem Mapped Type k√∂nnen wir diese Regel auf Typ-Ebene dynamisch umsetzen, und so diesen pr√§zisen R√ºckgabe-Typ erzeugen.
---
### Mapped Types
* Um den R√ºckgabe-Typ von `validateObject` zu beschreiben, k√∂nnen wir einen eigenen Typen definieren (`ValidatedObject`)
* Der `ValidatePerson`-Typ kann generisch beschrieben werden, so dass er _automatisch_ alle Properties
  aus einem Typen enth√§lt, deren Typ aber nun jeweils `boolean` ist. F√ºr den konkreten Typen `Person` s√§he das so aus:
  * ```typescript
      type Person = { firstname: string; age: number };
      type ValidatedObject = {
        [Key in keyof Person]: boolean
      }

      // ^?  { firstname: boolean; age: boolean }
    ```
* Den Ausdruck `keyof Person` kennen wir schon: hier wird ein Union Typ zur√ºckgeliefert, der aus allen Keys des Objekts besteht
* Mit `[Key in keyof Person]` wird an dieser Stelle √ºber alle Keys in dem Objekt "iteriert" und der Typ des jeweiligen Keys in die Typ Variable `Key` geschrieben
  * im Beispiel der `Person` w√§re das also: `firstname` und dann `age`
  * `Key` ist ein Variablenname, den ihr frei vergeben k√∂nnt.
* Auf der rechten Seite vom Doppelpunkt steht (wie gewohnt) der Typ f√ºr das jeweilige Property (hier also: `boolean`)  

---
### Mapped Types
* Nat√ºrlich k√∂nnen wir alle m√∂glichen Ver√§nderungen im Ziel-Objekt vorgenommen werden, z.B. auch `readonly` hinzugef√ºgt, oder Felder optional gemacht werden:
  * ```typescript
    type ValidatedPerson = {
      readonly [Key in keyof Person]?: boolean
    }

    //  ^?  { readonly firstname?: boolean, readonly age?: boolean }
    ```
* Es gibt bereits fertige [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html) f√ºr eine Vielzahl typischer Anwendungsf√§lle,
  z.B. [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype), [Required](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype) oder [Readonly](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)

---
### Mapped Types #2
* Im vorherigen Beispiel haben wir allen Eintr√§gen eines Objekts einen fixen neuen Typen (`boolean`) zu gewiesen.
* Es gibt aber auch F√§lle, in denen der Typ eines Eintrags aus dem Typen des Originals abgeleitet werden soll.
* In einer modifizierten Variante der `validate`-Funktion, liefert diese nun nicht mehr `boolean` zur√ºck, sondern den Original-Wert eines Feldes oder `null`, falls dieser ung√ºltig ist:
* ```javascript
  function validateField(value) {
    // Validierungslogik...
    return value; // oder null falls ung√ºltig
  }

  function validateObject(object) {
    // unver√§ndert...
  }  
  ```
* Wenn wir ein Objekt des `Person`-Typen validieren lassen, m√ºsste der R√ºckgabe-Typ folglich so aussehen:
* ```typescript
  const result = validateObject( { firstname: "Klaus", age: 32} )
     // ^?  { firstname: string | null, age: number | null }
  ```
---
### Mapped Types #2  
* √úber den Index Access k√∂nnen wir beim Erzeugen des neuen Typen auf die urspr√ºnglichen Typen der Properties des Original-Typen zugreifen
* Damit k√∂nnen wir zum Beispiel einen Typen bauen, der alle Properties aus dem urspr√ºnglichen Typen hat, diese sind aber im neuen Typen nullable:
* ```typescript
  type Person = {
    firstname: string,
    age: number
  }

  type ValidatedObject = {
    [Key in keyof Person]: Person[Key] | null
  }
  // ^? { firstname: string | null, age: number | null }

  declare function validate(p: Person): ValidatedObject;

                                          
  ```
---
### Mapped Types mit Generics

* Unsere `validate`-Funktion soll eigentlich _beliebige_ Objekte validieren und nicht nur `Person`-Objekte.
* Daher muss unser `ValidatedObject`-Typ _generisch_ sein und eine Typ-Variable verwenden
* Die Typ-Variable gibt den zu transformierenden Typen an (z.B. `Person`)
* Damit kannst Du _beliebige_ Typen in andere Typen transformieren:
* ```typescript
  type ValidatedObject<OBJECT extends object> = {
    [Key in keyof OBJECT]: OBJECT[Key] | null
  }

  type ValidatedContact = ValidatedObject<{phone: string, mobile: boolean}>;
        // ^? { phone: string | null, mobile: boolean | null }
  ```
* Wie muss die Signatur von der `validate`-Funktion jetzt aussehen? ü§î
* ```typescript
  declare function validate<O extends object>(o: O): ValidatedObject<O>;
  
  const person = { firstname: "Klaus", age: 123 };
  const result = validate(person);
        // ^? { firstname: string | null, age: number | null }

  ```

---
### √úbung Mapped Types:

* Schreibe die Typ-Definitionen f√ºr eine weitere Variante der Validation-Funktion!
  - Der `validate`-Funktion soll nun als zweiten Parameter ein Objekt √ºbergeben entgegen nehmen.
     - Daran enthalten sind Callback-Funktionen (`ValidatorFn`), in der jeweils die Validierungsregel f√ºr ein Property implementiert ist
  - Die `validate`-Funktion liefert ein Objekt zur√ºck, in dem die Validierungsergebnisse der einzelnen Felder (true/false)
    enthalten sind
  - In JavaScript w√ºrde das z.B. so aussehen:    
  * ```typescript
    function validate(person, validators) { /* ... */ }

    const person = { firstname: "Mo", age: 32}
    const personValidators = { 
      firstname(s) { return s.length > 3 }, // s soll korrekt als 'string' abgeleitet werden
      age(a) { return age > 0 } // a soll korrekt als 'number' abgeleitet weden
    }
    const result = validate(person, personValidators);
          // ^ { firstname: boolean, age: boolean }
    ```
---
### √úbung Mapped Types    
* <!-- .element: class="todo" -->Hinweisen: entweder Typ f√ºr Validator-Objekt erst bauen, oder die validator-Funktionen beim Aufruf der Methode angeben, sonst kann TS die Argumente nicht ableiten
* <!-- .element: class="todo" -->deswegen erst `ValidatorsObjekt` bauen (lassen)
* Die `validate`-Funktion soll zwei Parameter haben:
  1. Das zu validierende Objekt 
  2. Ein Objekt, das Funktionen zum Validieren enth√§lt
    - F√ºr jedes Property aus dem zu validierenden Objekt soll es eine (Callback-)_Funktion_ geben, die so hei√üt, wie das Property
    - Diese Funktion soll einen Parameter haben, der denselben Typ wie das Property hat und `true` oder `false` zur√ºckliefern (wie gesehen)
* Die `validate`-Funktion soll ein Objekt zur√ºckliefern, das dieselben Keys wie das zu validierende Objekt hat. Die Typen sollen aber jeweils `boolean` und `readonly` sein.
* Dann sollte folgendes funktionieren bzw. einen Fehler erzeugen:
* **Optional:**
  - Kannst Du die Signatur so bauen, dass das `validateFn`-Objekt eine Untermenge des zu validierenden Objekts ist? Man also f√ºr ein Feld im zu validierenden Objekt eine Validator-Callback-Funktion angeben kann oder nicht?
<!-- .element: class="todo" -->todo: L√∂sung lieber in √úbungsdatei, 
* ```typescript
const p = { firstname: "Klaus", lastname: "Meier", age: 32 };
personValidator.age?.(7); // OK
personValidator.age?.("fadfas"); // Argument of type 'string' is not assignable to parameter of type 'number'

  ```
---
### M√∂gliche L√∂sung
<!-- .slide: class="left" -->
* ```typescript
  // Ein Typ f√ºr das Ergebnis der validate-Funktion
  type ValidationResult<O> = {
    readonly [K in keyof O]: boolean;
  };

  // Typ f√ºr eine Validator Callback-Funktion
  type ValidatorFunction<V> = (value: V) => boolean;

  // Typ f√ºr das Objekt, das die Validator Callback-Funktionen enth√§lt
  type ValidatorObject<O extends object> = {
    readonly [K in keyof O]: ValidatorFunction<O[K]>;
  };

  // die validateObjekt-Funktion
  declare function validateObject<O extends object>(
    o: O,
    validators: ValidatorObject<O>
  ) => ValidationResult<O>;

  // Teil 2: Validator-Funktionen sind optional
  declare function validateObject<O extends object>(
    o: O,
    validators: ValidatorObject<Partial<O>>
  ) => ValidationResult<O>;  
  ```


---
### Conditional Types

* Mit [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) kannst Du abh√§ngig von einer Bedingung einen Typen oder einen anderen Typen ausw√§hlen
* Die Syntax dabei ist identisch mit dem tern√§ren Operator (`?`) in JavaScript (`a === true ? "ja!" : "nein!"`)
* Nur dass dabei _Typen_ statt _Werte_ angegeben werden:
  * ```typescript
    type NumberOrNull<O> = O extends string ? number : null;

    type S = NumberOrNull<"huhu"> // N = number
    type N = NumberOrNull<123> // N = null
    type A = NumberOrNull<true>; // A = null
    ```
  * ```typescript
    type IsPerson<O> = O extends { firstname: string, lastname: string} ? true : false
    ```

* Conditional Types lassen sich verschachteln (genau wie beim tern√§ren Operator):
  * ```typescript
    type NumberOrStringOrNull<O> = O extends string ? number 
                                 : O extends boolean ? string 
                                 : null

    type T1 = NumberOrStringOrNull<"huhu">; // T1 = string
    type T2 = NumberOrStringOrNull<123>; // T2 = null
    type T3 = NumberOrStringOrNull<true>; // T3 = string     
    ```
    
---
### Verwendung von Conditional Types
    
* Beispiel: 
  * Eine Funktion nimmt einen `string` oder `null` entgegen. 
  * Wenn sie mit `string` aufgerufen wurde, soll sie dessen L√§nge zur√ºckgeben (`number`)
  * Wenn sie mit `null` aufgerufen wurde, soll sie `null` zur√ºckliefern
  * ```typescript
    // So geht's nicht üò¢
    declare function getLength(s: string | null): number | null; 

    const a = getLength("123"); // a: number | null 
    const b = getLength(null); // b: number | null
    ```
* Mit Generics und einem Conditional Type l√§sst sich das umsetzen: 
* ```typescript
    declare function getLength<O extends string | null>(s: O): O extends string ? number : null;

    const a = getLength("123"); // a: number
    const b = getLength(null); // b: null
  ```

---
### Conditional Types mit Union Types

* Wenn Du einen _Union Type_ √ºbergibst, wird die √úberpr√ºfung f√ºr jeden Typen aus dem Union Type durchgef√ºhrt und ein neuer Union Type zur√ºckgeliefert:
* ```typescript
  type NumberOrNull<O> = O extends string ? number : null;

  type R = NumberOrNull<string | null | boolean>; 
    // R = number | null:
    // string wird zu 'number'
    // null und boolean werden beide zu 'null'
  ```

---
### Conditional Types mit `never`

* Wenn `never` in einem _Union Type_ vorkommt, wird dieser Typ "herausgefiltert"
* ```typescript
  type X = string | boolean | never; // X = string | boolean
  ```
* Das kanst Du nutzen, um mit einem Conditional Type aus einer Liste von Typen welche herauszufiltern
* ```typescript
  type NotNull<O> = O extends null ? never : O
  type T = NotNull<string>; T = string
  type T1 = NotNull<string | null>; // T1 = string
  type T2 = NotNull<string | boolean | null | undefined>; // T2 = string | boolean | undefined

  // Macht hier kein Sinn, aber s. weiteres Beispiel sp√§ter
  type TX = NotNull<null>; // T2 = never
  ```
* `extends` kann ebenfalls einen Union Typen aufnehmen:
* ```typescript
  type NotNullOrUndefined<O> = O extends null | undefined ? never : O
  type T3 = NotNullOrUndefined<string | null>; // T3 = string
  type T4 = NotNullOrUndefined<string | boolean | undefined>; // T4 = string | boolean
  ```
---
### Conditional Types mit `never`
* Fachliches Beispiel: eine Funktion, die sicherstellt, dass ein Wert nicht null ist
* Wenn der √ºbergebene Wert `null` ist, wirft die Funktion zum Beispiel einen Fehler
* Wenn der Wert nicht `null` ist, liefert die Funktion den Wert unver√§ndert zur√ºck
* ```typescript
  type NotNull<O> = O extends null ? never : O
  declare function ensureNotNull<O>(o: O): NotNull<O>;

  const c = ensureNotNull("huhu"); // c = string

  // hier macht 'never' jetzt Sinn, da die Funktion 
  // tats√§chlich nie zur√ºckkommt
  const b = ensureNotNull(null); // b = never
  ```
---
### Type Inference mit Conditional Types

* Mit einem Conditional Type k√∂nnen wir nicht nur Typen √ºberpr√ºfen, sondern auch Typen _extrahieren_ lassen
* Beispiel:
  * Eine Funktion nimmt einen Parameter entgegen
  * Der R√ºckgabetyp soll dem Typen des Parameters entsprechen. Wie das geht, haben wir schon gesehen:
  * ```typescript
    declare function check<O>(o: O): O;
    ```
  * Wenn der √ºbergebene Parameter aber selbst eine Funktion ist, soll deren(!) R√ºckgabetyp zur√ºckgeliefert werden:
  * ```typescript
    check( () => 123 ); // R√ºckgabetyp soll number sein
    check( () => "Hallo" ); // R√ºckgabetyp soll string sein
    ```
---
###  Type Inference mit Conditional Types 
  * Mit einem Conditional-Type k√∂nnen wir pr√ºfen, ob etwas ein Funktion ist.
  * Dazu schreiben wir als zu pr√ºfenden Typ eine (allgemeine) Funktionssignatur hin:
  * ```typescript
    O extends (...args: any) => any ? /* Funktion */ : /* Keine Funktion */
    ```
* Wenn der Ausdruck des Conditional Types _true_ ist, wissen wir das es eine Funktion ist. In dem Fall k√∂nnen wir mit `infer` die Typen der Parameter
  und/oder des R√ºckgabewertes extrahieren und in eine neue Typ-Variable schreiben lassen.
  * ```typescript
  O extends (...args: any) => infer A ? 
     /* Funktion: hier haben wir jetzt O und A */ 
     : 
     /* Keine Funktion, nur O */
    ```
  * Das k√∂nnen wir nun nutzen, um unsere Anforderung umzusetzen:
  * ```typescript
    declare function check<O>(o: O): O extends (...args: any) => infer A ? A : O
    ```
---
###  Type Inference mit Conditional Types 
* Weitere Beispiele
* ```typescript
  // R√ºckgabe-Wert f√ºr eine Funktion ohne Parameter:
  type RetValue<O> = O extends () => infer R ? R : never
  ```
* ```typescript
  // Ermitteln des ersten Arguments einer Funktion:
  type FirstArg<O> = O extends (a: infer A, ...args: any) => any ? A : never
  ```
* Was ist der Unterschied zu diesem Beispiel und warum sollte man das eine oder das andere machen? ü§î
* ```typescript
  type FirstArg<O extends (a: any, ...args: any) => any> = O extends (a: infer A, ...args: any) => any ? A : never
  ```
* Typ eines Arrays ermitteln:
* ```typescript
  type TypeOfArray<A> = A extends (infer A)[] ? A : never

  type T1 = TypeOfArray<string[]> // string
  type T2 = TypeOfArray<string>; // never
  ```
* F√ºr typische Anforderungen gibt es bereits fertige _Utility Typen_, z.B.:
  * [Awaited](https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype): Liefert Typ von Promises zur√ºck
  * [ReturnType](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype): R√ºckgabe-Typ einer Methode
  * [InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype): Typ der Instanz einer Klasse
  

---
### √úbung: Conditional Types

* Erweitere die `validate`-Funktion
  - Wenn der Typ einer Eigenschaft im Original-Objekt eine Funktion ist, soll deren R√ºckgabe-Type (oder null) im `ValidatedObject` auftauchen
  - Fachlicher Hintergrund: beim Validieren des Objektes werden daran enthaltenen Funktionen ausgef√ºhrt und dann deren R√ºckgabetyp validiert.
* ```typescript
  type Person = {
    firstname: string;
    age: number;
    hobbies: () => string[]
  }

  type ValidatedPerson = {
    firstname: string | null;
    age: number | null;
    hobbies: string[] | null; // 'string[]' ist R√ºckgabe-Typ von Person.hobbies
  }
  ```
* Erweiterung: wenn eine Eigenschaft eine Funktion ist, die `void` zur√ºckgibt, soll diese Eigenschaft nicht in `ValidatedObject`
  vorkommen (wenn sie keinen Wert zur√ºckliefert, kann sie nicht f√ºr die Validierung verwendet werden).
  * <!-- .element: class="todo" -->Hinweis, wie man keys mit `as never` entfernt
* ```typescript
  type Person = {
    firstname: string;
    hobbies: () => string[]
    incrementAge(): void;
  }

  type ValidatedPerson = {
    firstname: string | null;
    hobbies: string[] | null; 
    // incrementAge nicht vorhanden, weil R√ºckgabetyp void
  }
  ```

---
### Template Literal Types
<!-- .slide: class="left" -->
* Zur Erinnerung: ein konkreter String kann ein Typ in TypeScript sein.
* Damit k√∂nnen wir zum Beispiele eine Art Aufz√§hlungstyp bauen, um sicherzustellen, dass nur semantisch korrekte Strings
  an einer Stelle verwendet werden:
* ```typescript
  type Direction = "top" | "right" | "bottom" | "left";

  declare function setMargin(d: Direction, size: string): void;

  setMargin("top", "2rem"); // ok
  setMargin("middle", "2rem"); // ERR: Argument of type '"middle"' is not 
                               //      assignable to parameter of type 'Direction'
  ```
- Hier kann die `setMargin`-Funktion als `d` nur die String-Werte `top`, `right`, `bottom`, oder `left` entgegennehmen.
- Der zu setzende Wert (`size`) wird als beliebiger String √ºbergeben.
- Wie k√∂nnen wir sicherstellen, das auch der zweite String nicht beliebig ist, sondern dem Format `Gr√∂√üe + Einheit` enstpricht (`2rem`, `24px`, ...)
---
### Template Literal Types
<!-- .slide: class="left" -->
- Analog zu einem Template String in JavaScript k√∂nnen wir in TypeScript mit einem [Template Literal Type](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) "Regeln" f√ºr String-Typen beschreiben.
- Dazu verwenden statt der Anf√ºhrungszeichen die Backticks (`` ` ``) und k√∂nnen darin wie in JavaScript mit `${...}` Platzhalter definieren.
- In die Platzhalter werden dann erlaubte Werte(mengen) eingesetzt.
- Die Gr√∂√üenanabge f√ºr `setMargin` soll sich aus einer Zahl (`number`) und einer Einheit (`string`) zusammensetzen und k√∂nnte im ersten Schritt so definiert werden:
* ```typescript
  type Size = `${number}${string}`

  declare function setMargin(d: Direction, size: Size): void;

  setMargin("top", "2rem"); // OK
  setMargin("top", "XL"); // ERR
  setMargin("top", "A4"); // ERR
  setMargin("top", "2"); // OK (Leerstring...)
  ```
---
### Template Literal Types
 
* Wie k√∂nnen wir Ausdr√ºcken, dass die Einheit nur `em`, `rem` oder `px` sein darf?  
* Wir erlauben nicht mehr beliebige, sondern nur noch konkrete Strings:
* ```typescript
  type Size = `${number}em` | `${number}rem` | `${number}px`

  declare function setMargin(d: Direction, size: Size): void;

  setMargin("top", "2em"); // OK
  setMargin("top", "1.5rem"); // OK
  setMargin("top", "24pt"); // ERR
  setMargin("top", "2"); // ERR
  ```
---
### Template Literal mit Union Types
 
* Der gesehene `Size`-Typ funktioniert, kann bei vielen Auspr√§gungen aber un√ºbersichtlich werden
* Wir k√∂nnen stattdessen f√ºr die Einheit selbst einen Union Typen verwenden, der die erlaubten Einheiten beschreibt
* Wenn ihr einen Union Type in einem Template Literal einsetzt, enth√§lt der neue Typ alle Kombinationen aller enthalten Union Types:
* ```typescript
  type Unit = "em" | "rem" | "px"
  type Size = `${number}${Unit}`
  // oder: 
  // type Size = `${number}${"em" | "rem" | "px"}`

  declare function setMargin(d: Direction, size: Size): void;

  setMargin("top", "2em"); // OK
  setMargin("top", "1.5rem"); // OK
  setMargin("top", "24pt"); // ERR
  setMargin("top", "2"); // ERR
  ```
---
### Template Literal mit Union Types
* Als weiteres Beispiel soll eine Verallgemeinerung von `setMargin` dienen.
* Diese Funktion soll jetzt  `margin` oder `padding` setzen k√∂nnen.
* Die Angabe soll dabei (wie in CSS) als String mit Direction erfolgen.
* Hier k√∂nnen wir zwei Union Types in unser Template Literal einsetzen. 
* ```typescript
  type Spacing = "margin" | "padding";
  type Direction = "top" | "right" | "bottom" | "left";
  type CSSClassNames = `${Spacing}-${Direction}`;

  type Size = `${number}${"em" | "rem" | "px"}`

  declare function setSpacing(c: CSSClassNames, size: Size): void;

  setSpacing("margin-right", "2rem");  // OK
  setSpacing("padding-center", "2rem"); // ERROR
  ```
* K√∂nnen wir das so erweitern, dann man einen (mehr oder weniger) kompletten, g√ºltigen CSS-Ausdruck hinschreiben muss, so dass folgendes geht:
  * `setSpacing("margin-right: 2rem")` ‚úÖ
  * `setSpacing("margin-middle: 2rem")` ‚ùå
  * `setSpacing("padding-top: 24pt")` ‚ùå
---
### String Manipulation in Template Literal Types

* Nehmen wir an, wir wollen f√ºr fiktive Events den Namen ihrer `addListener`-Funktion ermitteln
  * Die `addListener`-Funktion soll den Event-Namen in ihrem Namen tragen
  * Das k√∂nnte folgende Regel auf Wert-Ebene sein:
  * ```typescript
    const changeEvent = "change";
    const changeListenerName = "addChangeListener"

    const insertEvent = "insert";
    const insertListenerName = "addInsertListener"
    ```
* Prinzipell k√∂nnten wir daf√ºr folgenden Typen definieren:
* ```typescript
  type ListenerName<E extends string> = `add${E}Listener`;
  ```
* Dann ist allerdings der Event-Name falsch geschrieben (Kleinbuchstabe!):
* ```typescript
  type ChangeListenerName = ListenerName<"change">;
        // ^?  addchangeListener
  const changeListenerName: ChangeListenerName = "addChangeListener"    
        // ERROR: Type '"addChangeListener"' is not assignable to type '"addchangeListener"'
  ```
* Wir m√ºssen also den urspr√ºnglichen String manipulieren
---
### String Manipulation in Template Literal Types
* Um einen String-Typen zu manipulieren, stellt TypeScript [einige Hilfstypen](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types) zur Verf√ºgung:
* `Uppercase`
* ```typescript
  type S = UpperCase<"change"> // "CHANGE"
  ```
* `Lowercase`
* ```typescript
  type S = UpperCase<"CHANGE"> // "change"
  ```
* `Capitalize`
* ```typescript
  type S = Capitalize<"change"> // "Change"
  ```
* `Uncapitalize`
* ```typescript
  type S = Uncapitalize<"Change"> // "change"
  ```  
* Damit k√∂nnen wir unseren Typen nun korrekt ausdr√ºcken!
* ```typescript
  type ListenerName<E extends string> = `add${Capitalize<E>}Listener`;

  type ChangeListenerName = ListenerName<"change">;
        // ^?  addChangeListener üòä

  const changeListenerName: ChangeListenerName = "addChangeListener" ‚úÖ
  ```
---
### √úbung: Template Literal Types
<!-- .slide: class="left" -->
* √úbung eventuell f√ºr JS Days rausnehmen 
<!-- .element: class="todo" -->
* Erweitere den `Spacing` bzw. `CSSClassnames`-Typen, so dass er einem (mehr oder weniger) kompletten, g√ºltigen CSS-Ausdruck entspricht:
  * `setSpacing("margin-right: 2rem")` ‚úÖ
  * `setSpacing("margin-middle: 2rem")` ‚ùå
  * `setSpacing("padding-top: 24pt")` ‚ùå
* Etwas trickreich:
  * Schreibe einen `SwapCapitalize`-Typen, der einen `string` entgegennimmt 
    - Wenn der String mit einem Gro√übuchstaben anf√§ngt, soll der String mit Kleinbuchstaben zur√ºckgeliefert werden, sonst umgekehrt
  * ```typescript
    type Swap<S extends string> = "todo";

    type A = Swap<"addListener">;
      // ^?  "AddListener"

    type B = Swap<"AddListener">;
      // ^?  "addListener"
    ```
* Sehr trickreich:
  * Kannst Du den `Capitalize`-Typen selbst implementieren? ü§Ø ü§Ø ü§Ø  
  
---
### L√∂sung: Template Literal Types
<!-- .slide: class="left" -->
* CSS Ausdruck:
* ```typescript
  type CSSExpression = `${CSSClassNames}:${Size}`
  function setSpacing(c: CSSExpression) {}
  setSpacing("margin-right: 2rem"); // OK
  setSpacing("margin-middle: 2rem"); // ERR
  setSpacing("padding-top: 24pt"); // ERR
  ```
 
* Swap
  * ```typescript
    type Swap<S extends string> = S extends Capitalize<S> ? Uncapitalize<S> : Capitalize<S>

    type A = Swap<"addListener">;
      // ^?  "AddListener"

    type B = Swap<"AddListener">;
      // ^?  "addListener"  
    ```

---
### Keys mit Template Literal Types umbenennen
- Wenn ihr einen _Key_ in einem Mapped Type umbenennen wollt, k√∂nnt ihr das mit einem Template Literal Type tun
* Fachliches Beispiel:
  - Die schon gesehene `createSetter`-Funktion liefert Setter-Funktionen f√ºr ein ganzes Objekt (`anObject`) zur√ºck
  - Dazu gibt `createSetter` ein Objekt zur√ºck, in dem f√ºr jedes Feld in `anObject` eine Setter-Funktion enthalten ist
  - Die Keys im `setter`-Objekt sollen nun allerdings `setFieldname` und nicht mehr `fieldname` heissen:
  * ```typescript
    function createSetter(observedObject) { /* ... */ }
    const setters = createSetter( { firstname: "klaus", age: 32} ) ;
           // setters: { setFirstname(newValue) { /* ... */ }, setAge(newValue) { /* ... */ } }
    // √Ñndern des Vornamens:
    setters.setFirstname("Moni");
    ```
* üëâ Der zur√ºckgelieferte Typ muss also die Keys aus dem `observedObject` umbenennen.
  * Wir brauchen konzeptionell also so etwas:
  * ```typescript
    type SetterObject<O extends object> = {
      [Key in keyof O]: (newValue: O[K]) => void;
      // ^-- Hier muss Key umbenannt werden in `set${Capitalize<Key>}`
    }
    ```
---
### Keys mit Template Literal Types umbenennen

* Grunds√§tzlich k√∂nnen bei Mapped Types die Keys umbenannt werden
* Zur Erinnerung: `keyof` liefert eine Liste von _Typen_ zur√ºck (auch wenn diese meist wie "normale" Strings aussehen):
* ```typescript
  type KeysInPerson = keyof Person; // "firstname" | "age"
                                          ^------------^---- Typen! Keine Werte! Keine Strings!
  ```
* Um einem Key einen neuen Namen zu √§ndern, m√ºssen wir also dessen _Typ_ ver√§ndern
* Das kann man mit einem Type Cast (`as`) machen
* In Kombination mit einem Template Listeral Type zum Beispiel so
  * ```typescript
    // Achtung! Beispiel funktioniert so noch NICHT
    type SetterObject<O extends object> = {
      [Key in keyof O as `set${Capitalize<Key>}`]: (newValue: O[K]) => void;
    }
    ```
* Das funktioniert aber so noch nicht!
* Es gibt Compile-Fehler:
  * Im Template Literal d√ºrfen wir nur string, boolean, null etc. angeben aber kein `Symbol`
  * `Capitalize` erwartet sogar nur einen `string`

---
###  Keys mit Template Literal Types umbenennen
* Ein Template Literal Type kann nur mit dem Typ `string | number | bigint | boolean | null | undefined` arbeiten
* Der `Capitalize` ist noch restriktiver: dieser kann nur mit einem `string` verwendet werden
* Ein Eintrag in `keyof` kann neben `string` aber auch `number` oder `symbol` sein, weil diese als Keys an Objekten verwendet werden k√∂nnen
* ```typescript
  const person = {
    firstname: "Klaus",
    2: "zwei",
    [Symbol()]: "geheim",
  };
  ```
* Wir m√ºssen also die Typen aus `keyof` rausfiltern, die keine Strings sind
* Wie k√∂nnten wir das mit einem Union Type und `never` machen? ü§î
* ```typescript
  type StringKeysOf<O extends object, K = keyof O> = K extends string ? K : never
  ```
* Es gibt eine andere Alternative...
---
### Exkurs: Intersection und Union Types

* Ein _Intersection Type_ stellt eine "√úberschneidung" aus zwei Typen dar.
* ```typescript
    type Person = { firstname: string; age: number }
    type Address = { city: string; street: string }

    type PersonWithAddress = Person & Address; // Intersection type
  ```
* Da der Typ `PersonWithAddress` die Gemeinsamkeiten von `Person` und `Address` darstellt, m√ºssen auch alle Eigenschaften beim Instaniieren des Typs angegeben werden:
* ```typescript
  const p: PersonWithAddress = { 
    firstname: "Klaus", age: 32,
    city: "Hamburg", street: "Reeperbahn"
   };
  ```
* Der Verwender dieses Typs kann sich dann aber darauf verlassen, alle Eigenschaften von `Person` _und_ `Address` zu haben:
* ```typescript
  function sendLetter(p: PersonWithAddress) {
    p.firstname.toUpperCase(); // OK
    p.city.toUpperCase(); // OK
  }
  ```
* Bei einem _Union Typen_ ist es genau andersrum.
---
### Exkurs: Intersection und Union Types
* Ein _Union Type_ enth√§lt die Eigenschaften aus dem einen _oder_ dem anderen Typen:
* ```typescript
  type Person = { firstname: string; age: number }
  type Animal = { name: string; species: string }

  type PersonOrAnimal = Person | Animal;
  ```
* Um ein `PersonOrAnimal` zu erzeugen, reicht es, die Eigenschaften von `Person` _oder_ `Animal` anzugeben:
* ```typescript
  type klaus: PersonOrAnimal = { firstname: "Klaus", age: 32 };
  ```
* Der Verwender kann sich dann nicht sicher sein, welche Eigenschaften er hat (`Person`, `Animal` oder beide), und muss einen entsprechenden _Type Guard_ pr√ºfen, welche Auspr√§gung vorliet:
* ```typescript
  function sayHello(p: PersonOrAnimal) {
    p.firstname.toUpperCase(); // ERROR: Property 'firstname' does not exist on type 'PersonOrAnimal'.
                               //     Property 'firstname' does not exist on type 'Animal'

    if ("firstname" in p) {
      p.firstname.toUpperCase(); // OK
        // p = Person  
    }                               
  }

  ```
---
### Exkurs: Intersection und Union Types
* Was passiert nun, wenn beide Typen kombiniert werden? üôÄ
* ```typescript
  type ColorsOfFrance = "blue" | "white" | "red"
  type ColorsOfSwiss = "red" | "white";

  type ColorsOfSwissAndFrance = ColorsOfSwiss & ColorsOfFrance
         // ^? ???
  ```
* Richtig ist die Schnittmenge der Farben:
  * ```typescript
    type ColorsOfSwissAndFrance = ColorsOfSwiss & ColorsOfFrance
            // ^? "red" | "white"
    ```
  * Wenn es nicht die Schnittmenge w√§re, sondern die Menge aller Auspr√§gungen aller Union Typen (`"blue" | "white" | "red"`), k√∂nnten wir einen Typen 
erzeugen, der hinterher nicht mehr an `ColorsOfSwiss` zuweisbar w√§re:   
  * ```typescript
  type AllColorsOfSwissAndFrance = "blue" | "white" | "red";
  const c: AllColorsOfSwissAndFrance = "blue";
  const f: ColorsOfFrance = c; // OK
  const s: ColorsOfSwiss = c; // ERR Type '"blue"' is not assignable to type 'ColorsOfSwiss'
  ```
---
### Exkurs: Intersection und Union Types
* Was passiert, wenn diese beide Typen kombiniert werden? üôÄ
* ```typescript
  type StringOrNum = string | number;
  type StringOrBoolean = string | boolean
  type StringOrNumAndStringOrBoolean = StringOrNum & StringOrBoolean
         // ^? ???
  ```
  * Ebenfalls die Schnittmenge, gleicher Fall wie vorher nur mit anderen Typen:
* ```typescript
  type StringOrNumAndString = StringOrNum & string
  type StringOrNumAndStringOrBoolean = StringOrNum & StringOrBoolean
        // ^? string
```
* Und nun die Keys aus unserem `Person`-Objekt:
* ```typescript
  type Person = { firstname: string, 2: [Symbol()]: "geheim" }

  type KeysOfPerson = keyof Person; 
         
  type KeysOfPersonAndString = KeysOfPerson & string
         // ^? ???
  ```
  * Ebenfalls selbes Prinzip, nur das der Union Typ diesmal aus `keyof` kommt:
    * ```typescript
      type KeysOfPerson = keyof Person; 
        // ^?  "firstname" | 2 | symbol;

      type KeysOfPersonAndString = KeysOfPerson & string
        // ^? "firstname"
      ```


---
###  Keys mit Template Literal Types umbenennen
* Alle Keys die nicht vom Typ `string` sind, werden damit rausgefiltert und sind im neuen Objekt nicht vorhanden.
* ```typescript
  type SetterObject<O extends object> = {
    [Key in keyof O & string as `set${Capitalize<Key>}`]: (newValue: O[Key]) => void;
  }
  ```
  
* ```typescript
  declare function createSetter<O extends object>(o: O): SetterObject<O>;

  const setters = createSetter( { firstname: "klaus", age: 32} ) ;
  // √Ñndern des Vornamens:
  setters.setFirstname("Moni"); // ‚úÖ
  setter.firstname("Moni"); // ‚ùå
  ```
* Ob das Entfernen der nicht-String-Keys korrekt ist, ist eine fachliche Frage
  * Was k√∂nnten wir stattdessen? ü§î 

---
### √úbung: Template Literal Types
<!-- .element: class="todo" -->
<!-- .element: class="todo" -->JS Days: lange Herleitung mit Union und Intersection Type evtl. raus, einfach nur auf `&` hinweisen
<!-- .element: class="todo" -->Dann hier eine √úbung, die mit dem Validator-Funktion erweitert (z.B. Keys im ValidatedObject sollen anders hei√üen)

---
### Conditional Types mit Template Literal Types
<!-- .slide: class="left" -->
- <!-- .element: class="todo" -->f√ºr JS Days evtl. zu viel
* Mit einem Conditional Type k√∂nnen wir pr√ºfen, on ein Typ einem (String-)Muster entspricht
* ```typescript
  type IsAddListenerName<S> = S extends `add${string}Listener` ? true : false;

  type IsChangeListener = IsAddListenerName<"addChangeListener">; // "true"
  type IsUpdateListener = IsAddListenerName<"updateListener">; // "false"
  ```
* Das `${string}` matched auf einen beliebigen String (gleiches geht mit `${boolean}` oder `${number}`)
* Es k√∂nnen auch Platzhalter √ºbergeben werden:
* ```typescript
  type IsAddListenerForEventName<S, E> = S extends `add${Capitalize<E>}Listener` ? true : false;

  type IsChangeListener = IsAddListenerForEventName<"addChangeListener", "change">; // "true"
  type IsChangeOrUpdateListener = IsAddListenerForEventName<"addChangeListener", "change" | "update">; // "true"
  type IsUpdateListener = IsAddListenerForEventName<"addChangeListener", "update">; // "false"
  ```
* Nat√ºrlich geht das auch mit Constraints:
* ```typescript
  type Event = "change" | "update";
  type IsAddListenerForEventName<S extends string, E extends Event> = 
                          S extends `add${Capitalize<E>}Listener` ? true : false;
  // Verwendung wie oben
  ```
* ...oder mit Defaults:
* ```typescript
  type Event = "change" | "update";
  type IsAddListenerForEventName<S extends string, E extends Event = "change"> = 
                          S extends `add${Capitalize<E>}Listener` ? true : false;
  type IsChangeListener = IsAddListenerForEventName<"addChangeListener">; // "true"
  type IsUpdateListener = IsAddListenerForEventName<"addUpdateListener">; // "false"
    ```

---
### Template Literal Types mit infer
<!-- .slide: class="left" -->
* Mit dem `infer` Schl√ºsselwort k√∂nnt ihr Euch den "eingesetzten" Teil in eine Typ-Variable extrahieren lassen
  * Analog zu dem, was wir zuvor schon bei den Conditional Types gesehen haben:
* ```typescript
  type GetEventNameFromListener<S extends string> = S extends `add${infer EN}Listener` ? Uncapitalize<EN> : never;
    
  type ChangeEvent = GetEventNameFromListener<"addChangeListener">; // "change"
  type NoChangeEvent = GetEventNameFromListener<"addChangeHandler">; // never
  ```
* Auch die Platzhalter lassen sich mit Constraints kombinieren:
* ```typescript
  type GetEventNameFromListener<S extends string> 
         = S extends `add${infer EN extends Event}Listener` ? Uncapitalize<EN> : never;

  type ChangeEvent = GetEventNameFromListener<"addChangeListener">; // "change"
  type NoEvent = GetEventNameFromListener<"addInsertListener">; // never
  type NoListener = GetEventNameFromListener<"addChangeHandler">; // never
  ```
* Damit lassen sich sehr m√§chtige Dinge bauen, z.B. [SQL "Datenbanken"](https://github.com/codemix/ts-sql) ü§Ø 
---
### √úbung Template Literal Types mit infer
* Ein Typ `S` besteht aus zwei W√∂rtern, die mit Bindestrich getrennt sind (z.B. `"margin-left"` oder `"padding-right"`)
* Baue einen Typen, der den Inhalt von `S` in camelCase-Notation zur√ºckliefert ("`marginLeft"` oder `"paddingRight"`)
* Wenn der √ºbergebene Typ nicht dem Muster (`string1-string2`) entspricht, liefer den Typen unver√§ndert zur√ºck oder gib `never` zur√ºck
* Beispiel
  * ```typescript
    type CamelCase<S extends S> = /* ... */
    
    const marginLeft:CamelCase<"margin-left">  = "marginLeft";
    const paddingRight:CamelCase<"padding-right">  = "paddingRight";
    ```
* Erweiterung 1: Kannst Du den Typen so bauen, dass er aus beliebig vielen W√∂rtern camelCase erzeugt?
* ```typescript
    const background:CamelCase<"background"> = "background";
    const marginLeft:CamelCase<"margin-left"> = "marginLeft";
    const maxPageWidth:CamelCase<"max-page-width"> = "maxPageWidth";
  ```
* Erweiterung 2: Kannst Du den Typen so erweitern, dass man das Trennzeichen festlegen kann?  
* ```typescript
  const marginLeft:CamelCase<"margin-left", "-"> = "marginLeft";
  const helloWorld:CamelCase<"hello world", " "> = "helloWorld";

  ```
---
### L√∂sungen
<!-- .slide: class="left" -->
* Zwei W√∂rter, mit Bindestrich getrennt:
  * ```typescript
    type ToCamelCase<S> = S extends `${infer left}-${infer right}`
      ? `${left}${Capitalize<right>}`
      : S;
    ```
* "Rekursiv", beliebige Anzahl an W√∂rtern mit Bindestrich getrennt: 
  * ```typescript
    type ToCamelCase<S> = S extends `${infer left}-${infer right}`
      ? ToCamelCase<`${left}${Capitalize<right>}`>
      : S;
    ```
* "Rekursiv" und mit variablem Trennzeichen:
  * ```typescript
    type ToCamelCase2<
      S,
      D extends string = "-" // D ist das Trennzeichen, per Default auf "-" vorbelegt
    > = S extends `${infer left}${D}${infer right}`
      ? ToCamelCase<`${left}${Capitalize<right>}`>
      : S;
    ```
---
### todo
* <!-- .element: class="todo" -->Alle √úbungen mit Ausgangsmaterial samt Beschreibung und L√∂sung als Source-Datei ins Repository!          
* <!-- .element: class="todo" -->Beispiele zusammenstellen, die Nils macht  
* <!-- .element: class="todo" -->Zeitplan f√ºr JSDays pr√ºfen


          </textarea>
        </section>
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit TypeScript!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            Mail:
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            Web:
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            Mastodon:
            <a href="https://norden.social/@nilshartmann" target="_blank"
              >@nilshartmann@norden.social
            </a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
