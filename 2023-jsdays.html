<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>TypeScript Workshop</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="slides/revealjs/reveal.js/dist/theme/solarized.css"
    />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link
      rel="stylesheet"
      href="slides/revealjs/highlight-js-github-theme.css"
    />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>TypeScript Advanced</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg"
                >https://github.com/nilshartmann/typescript-advanced-workshop</span
              >
            </p>
          </div>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2023-jsdays.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://nilshartmann.github.io/typescript-advanced-workshop/2023-jsdays.html"
                >
                  https://nilshartmann.github.io/typescript-advanced-workshop/2023-jsdays.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p style="margin-top: 2rem">
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>
          <p></p>
          <p style="margin-top: 5rem">
            Java | JavaScript, TypeScript | React | GraphQL
          </p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="slides/images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- Das Typsystem von TypeScript hilft uns in der täglichen Arbeit, typische Programmierfehler zu vermeiden. 
          Dazu schreiben wir Typ-Angaben zum Beispiel an Variablen oder Funktionsargumente. 
          Die Beschreibung der Typen selbst ist aber gar nicht immer so trivial. 
          Durch das dynamische Typsystem von JavaScript kann eine Funktion beispielsweise ein beliebiges Objekt entgegennehmen und in 
          einer abgeleiteten Form zurückgeben. 
          Für diese Herausforderung bringt TypeScript eine Art Meta-Sprache mit, mit der sich Typen an Hand verschiedener 
          Regeln programmieren lassen. Damit lassen sich auch für komplexe Anwendungsfälle, zum Beispiel APIs von Bibliotheken, 
          Typen beschreiben, so dass Nutzerinnen und Nutzer der Funktionen vollständige Typsicherheit haben - 
          ohne selbst Typdefinitionen schreiben zu müssen.


        In diesem Workshop sehen wir uns diese Meta-Sprache an Hand von Beispielen in der Praxis an. 
        Wir werden unter anderem Mapped Types, Utility Types und Conditional Types untersuchen und sehen, 
        für welche Anwendungsfälle sie jeweils geeignet sind.
         Dazu machen wir natürlich auch Übungen, so dass Du das Gelernte direkt Hands-on ausprobieren kannst. 
         Für den Workshop solltest Du grundsätzliche TypeScript-Kenntnisse mitbringen. 
        
        https://javascript-days.de/javascript/advanced-typescript/
        -->

        <!-- ######################################################  -->
        <section>
          <h2>Advanced TypeScript</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Hinweis!

* Wir konzentrieren uns hier nur auf die Typ-Ebene
* Die gezeigten Beispiele kommen daher ohne Implementierung aus
          </textarea>
        </section>

        <section>
          <h2>Eingebaute Typen: any und unknown</h2>
          <pre
            class="fragment"
          ><code class="typescript line-numbers" contenteditable data-trim>
  // unknown: kann ebefalls alle Typen aufnehmen, erzwingt aber vor der Verwendung Typ-Prüfung
  function loadData(): unknown { return "" // ok }
  let b = loadData(); 
  b.toUpperCase(); // ERROR
  if (typeof b === "string") {
    // b ist jetzt string (typeof ist Laufzeitprüfung!)
    b.toUpperCase(); // OK
  }
              </code></pre>
        </section>

        <section>
          <h2>Union Types</h2>
          <p>Variablen, Parameter etc. können mehr als einen Typ annehmen:</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

function printNameOrTitle(obj: Person | Movie) { 

  console.log(obj.title); // ERR: Property 'title' does not 
                          // exist on type 'Person | Movie'
 
  if ("title" in obj) { // Abfrage ist ein "Type Guard"
    // obj ist Movie hier, title ist definiert
    console.log(obj.title);
  } else {
    // obj ist Person hier: name ist definiert
    console.log(obj.name);
  }
}

printNameOrTitle({name: "Klaus"}); //OK
printNameOrTitle({title: "Pulp Fiction"}); //OK
printNameOrTitle({label: "Save"}); // ERR
    
          </code></pre>
        </section>
        <section>
          <h2>Type Guards</h2>
          <p>Durch einen Type Guard können Typen "eingeengt" werden</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion true zurueckgibt, nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie ist
function isMovie(candidate: any): candidate is Movie {
  return ("title" in candidate);
}

function printNameOrTitle(obj: Person | Movie) { 
  if (isMovie(obj)) {
    // movie
  }
}
    
          </code></pre>
        </section>
        <section>
          <h2>Type Assertions</h2>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type Person = { name: string };
type Movie = { title: string };

// Wenn diese Funktion zurueckkehrt (kein Error geworfen wird) nimmt Typescript an,
// dass das übergebene Argument vom Typ Movie  ist
function assertIsMovie(candidate: any): asserts candidate is  Movie {
  if ("title" in candidate) {
    return;
  }
  throw new Error("Candidate is not a movie!")
}

function printTitle(hopefullyAMovie: any) { 
  assertPersonIsMovie(hopefullyAMovie)
  // hopefullyAMovie ist jetzt Movie
  hopefullyAMovie.title; // OK
}
    
          </code></pre>
        </section>
        <section>
          <h2>String Literal Types</h2>
          <p>Beispiel: String Aufzählungstyp</p>
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Beispiel:             
type Answer = "Yes" | "No" | "I_dont_care";

const a1:Answer = "Yes"; // OK
const a2:View = "Maybe" // FEHLER

function fillIn(a: Answer) {
    if (a === "Yes") { ... } // ok
    if (a === "Maybe") { ... } // error: immer false
}

fillIn("I_dont_care"); //OK
fillIn("Maybe"); // ERROR
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Type Aliase
* Mit dem Schlüsselwort [`type`](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases) wird ein __Type Alias__ erzeugt.
* Ein Type Alias ist nur ein (anderer) Name für einen Typen
* Man kann immer entweder einen Type Alias oder einen kompletten Typen hinschreiben
  * ```typescript
    declare function createPerson(firstname: string, address: {city: string} ): 
                                        { firstname: string, address: { city: string } };

    // identisch mit: 
    type Person = {
      firstname: string
      address: { city: string }
    }
    type Address = {
      city: string;
    }
    declare function createPerson(firstname: string, address: Address ): Person;

    // identisch mit:
    type Address = {
      city: string;
    }
    type Person = {
      firstname: string
      address: Address
    }
    declare function createPerson(firstname: string, address: Address ): Person;
    ```
* Man verwendet immer das, was am besten passt
  * Für häufig verwendete oder komplexe Konstrukte lohnt sich ein Type Alias meistens  


---
### Index Access
* Mit dem Index Operator kannst Du in JavaScript/TypeScript auf Werte aus einem Objekt zugreifen:
* ```typescript
  const person = {
    firstname: "Klaus",
    address: { city: "Hamburg", street: Reeperbahn }
  }

  const address = person["address"];
  ```
* Etwas ähnliches kannst Du auch mit Typen machen, wenn du den Typ eines Properties benötigst:
* ```typescript
  type Person = {
    firstname: string
    address: { city: string }
  }

  type Address = Person["address"]
  ```
* Das kann zum Beispiel hilfreich sein, wenn Du einen Typen hast, den Du nicht selbst beschrieben hast. 
Zum Beispiel wenn der Typ aus einer Bibliothek stammt oder von einem Code Generator erzeugt wurde.

---
### Index Access #2
* Wenn Du den Typen eines Arrays benötigst, kannst Du statt eines Property-Namens `[number]` hinschreiben:
* ```typescript
  type Person = {
    contacts: [
      {
        email: string;
        phone: string;
      }
    ];
  };

  type Contacts = Person["contacts"];        // Array<{ email: string, phone: string }>
  type Contact = Person["contacts"][number]; //       { email: string, phone: string }

  declare function addContact(c: Contact): void;

  addContact({email: "nils@nilshartmann.net", phone: "..."})
  ```

---
### keyof

* [`keyof`](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) liefert einen Union Typen zurück, der alle Keys eines Objektes enthält
* ```typescript
  type Person = {
    firstname: string;
    lastname: string;
  }
  type PersonKeys = keyof Person; // "firstname" | "lastname"

  ```
* Damit kann man zum Beispiel erzwingen, das ein Funktionsparameter nur gültige
  Keys eines Objekts aufnehmen kann:
* ```typescript
  declare function logPropertyOfPerson(propName: keyof Person): void;

  logPropertyOfPerson("firstname"); // OK
  logPropertyOfPerson("age") // ERR: Argument of type '"age"' is not 
                             // assignable to parameter of type 'keyof Person'

  ```
---
### Der typeof-Operator

* Der `typeof`-Operator in JavaScript liefert den _Wert_ einer Variablen zur Laufzeit zurück.
* Mit dem [`typeof`-Operator von TypeScript](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#handbook-content) kann der Typ eines Werts auf Typ-Ebene ermittelt werden.
  * Im Grunde das, was die IDE tut, wenn ihr mit der Maus über einen Variable fahrt
* ```typescript
  const languages = {
    de: "DE",
    en: "EN"
  }

  type TLanguages = typeof languages;          // TLanguages ist TYPE,
                                               // languages ist WERT (VALUE)

  export declare function translateMessage(msg: string, lang: keyof TLanguages): string;

  // oder:
  type TLanguageKeys = keyof typeof languages;
  export declare function translateMessage(msg: string, lang: TLanguageKeys): string;
  ```
---
### Typen anzeigen
* In der Regel könnt ihr Euch in Eurem Editor oder Eurer IDE den Typen einer Variable anzeigen lassen, in dem ihr mit der Maus darüber fahrt  
* Im [TypeScript Playground](https://www.typescriptlang.org/play) könnt ihr mit `// ?^` unter einer Variablen Euch deren Typen anzeigen lassen
* ![Tooltip](./slides/images/screenshot-type-tooltip.png)
* Für VS Code gibt es dazu eine [Extension](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-twoslash-queries)

---
### Generics
* Mit `any` können wir Funktionen beschreiben, die alle möglichen Typen entgegennehmen
  und/oder zurückliefern
  * ```typescript
    declare function validate(obj: any): any
    ```
* Was machen wir aber, wenn wir den übergebenen Typen (für `obj`) an anderer Stelle benötigen?
  * Zum Beispiel, um sicherzustellen, dass der Rückgabe-Typ identisch ist?
* ```typescript
  const p = validate("hallo"); // p soll string sein (ist: any 😔)
  const n = validate(123); // n soll number sein (ist: any 😔)
  ```

---
### Generics
* Für Funktionen (und Typen) können **Typ Variablen** definiert werden
* Fast wie Funktionsparameter, nur dass keine __Werte__, sondern __Typen__ angegeben werden
* Die Typ Variable wird deklariert (`<VariablenName>`) und kann dann in der gesamten Funktionssignatur bzw. Typ-Definition verwendet werden
* Beispiele:
  * ```typescript
    // "O" ist Typ Variable
    declare function validate<O>(o: O): O
    const p = validate("hallo"); // p jetzt string 😊
    const n = validate(123); // n jetzt number 😊
    ```
* Mehr Beispiele:    
  * ```typescript
      // Idee liefert den übergebenen Wert zurück, oder
      // null falls dieser ungültig ist (was auch immer "ungültig" hier bedeutet)  
      declare function validate<O>(o: O): O | null
    ```
  * ```typescript
      // Ein Typ, der entweder eine Liste von Dingen ist oder null
      // (fachlich bescheuertes Beispiel, bessere Beispiele folgen...)
      type ListOrNull<O> = Array<O> | null;
    ```
---
### Generics
* Beim Verwenden in einer Funktion wird der __Typ__ entweder vom übergebenen __Wert__ abgeleitet:
* ```typescript
  declare function validate<O>(o: O): O | null
  const x = validate("Hallo"); // O ist string, x ist string | null
  const y = validate(7); // O ist number, y ist number | null
  ```
* ...oder der Typ wird explizit angegeben. Dann muss der __Wert__ dem angegebenen __Typen__ entsprechen:
* ```typescript
  validate<string>("Hallo"); // O ist string, Argument ist string: Alles OK!
  validate<string>(7); // O ist string, Argument ist number:
                       // ERR: Argument of type 'number' is not assignable to parameter of type 'string'
  ```
---
### Generics: Default-Werte
* Analog zu "normalen" Funktionsargumenten, können auch bei Generics Default**typen** angegeben werden
* Wie bei Funktionsargumenten kann auch nur der letzte bzw. die letzten Argumente Default-Typen haben
* ```typescript
  declare function validate<O, R = string>(o: O): O | R

  validate(7); // RückgabeTyp: number | string 
  validate<number>(7); // RückgabeTyp: number | string 
  validate<number, null>(7); // RückgabeTyp: number | null
  validate<number, boolean>(7); // RückgabeTyp: number | boolean
  ```
* ```typescript
  type Tuple<X, Y = string> = [X, Y];

  type TupleOfNumberAndStrings = Tuple<number>; // [number, string]
  type TupleOfStringAndBoolean = Tuple<string, boolean>; // [string, boolean]
  ```
* Wie bei Funktionsargumenten, können auch Typ Variablen an andere Typen weitergegeben werden:
* ```typescript
  type ReactUseStateTuple<V> = Tuple<V, (newValue: V) => void>;
         // [ V, function(a: V): void ]
  ```

---
### Generic: Constraints   
* Wie bei "normalen" Argumente, können die Typ-Argumente Einschränkungen haben:
* Die Einschränkungen werden mnit `extends` definiert
  * Der Übergenene Typ muss dann derselbe oder ein erweiterter sein:
* ```typescript
  declare function validateObject<O extends object>(o: O): O | null;

  validateObject({name: "Klaus"}); // OK
  validateObject({name: "Klaus"}); // ERR: Argument of type 'string' is not 
                                   // assignable to parameter of type 'object'

  ```
* ```typescript
  type Person = { firstname: string | null };
  declare function getOrDefault<P extends Person>(p: P): P;

  getOrDefault( { } ); // ERR: Property 'firstname' is missing in type '{}' 
                       // but required in type 'Person'
  ```
---
### Generics mit Union Typen  

* Wenn man einen Union Type als Constraint angibt, muss der übergebene Typ einem
  der im Union-Typen enthaltenen Typen entsprechen:  
* ```typescript
  type Color = "red" | "blue" | "green";
  declare function bgColor<C extends Color> (c: Color): { backgroundColor: C };

  bgColor("red"); // OK
  bgColor("white"); // Argument of type '"white"' is not 
                    // assignable to parameter of type 'Color'
  ```
* ```typescript
  type ListOfStringsOrBooleans<X extends string|boolean> = Array<X>
  const c1: ListOfStringsOrBooleans<string> = ["a"]; // Ok
  const c2: ListOfStringsOrBooleans<boolean> = [true]; // Ok
  const c3: ListOfStringsOrBooleans = [true, "jo!"]; // Ok

  const c4: ListOfStringsOrBooleans<number> = [4]; // ERR Type 'number' does not satisfy 
                                                   // the constraint 'string | boolean'

  declare function validateNumberOrString<O extends string|number>(o: O): O | null    
  ```

---
### Übung
* Beschreibe eine Typsichere `createSetter`-Funktion. Die Funktion soll eine fiktive Setter-Funktion für ein Property eines
beliebigen Objektes zurückliefern.
  * Fachliche Idee: in der Setter-Funktion können z.B. Überprüfungen durchgeführt werden oder die Setter-Funktion könnte den Wert in eine DB schreiben o.ä.
* Die Funktion soll zwei Parameter haben:
  1. Ein beliebiges Objekt (`someObject`), 2. Den Namen eines Keys aus dem Objekt (`aKey`)
* Der Rückgabe-Typ soll eine Funktion sein, die ihrerseits ein Argument hat, das vom Typ des Properties aus dem übergebenen
  Objekt (`someObject`) ist, so dass diese Funktion aufgerufen werden kann, um den Wert des Objektes zu setzen. 
* In JavaScript sähe das so aus:
  * ```javascript
    function createSetter(someObject, aKey) { /* ... */ } 

    const ageSetter = createSetter({firstname: "Klaus", age: 32}, "firstname");
    ageSetter(33);
    ```
* In TypeScript sollten dann folgende Beispiele funktionieren bzw. einen Fehler auslösen:
* ```typescript
  const person = { firstname: "Klaus", age: 32 }

  createSetter(person, "firstname")("newFirstName"); // OK
  createSetter(person, "xxx")("newFirstName"); // Argument of type '"xxx"' is not assignable to parameter of type '"firstname" | "age"
  createSetter(person, "age")(33); // OK
  createSetter(person, "age")("33"); // ERR // Argument of type 'string' is not assignable to parameter of type 'number'
  createSetter("Klaus", "klaus"); // Argument of type 'string' is not assignable to parameter of type 'object'
  ```
---
### Mögliche Lösungen
<!-- .slide: class="left" -->
* ```typescript
  declare function createSetter<O extends object, K extends keyof O>(
    someObject: O,
    aKey: K
  ): (newValue: O[K]) => void;
  ```
* ```typescript
  type SetterFn<Value> = (newValue: Value) => void

  declare function createSetter<O extends object, K extends keyof O>(
    someObject: O,
    aKey: K
  ): SetterFn<O[K]>
  ```
* ```typescript
  type SetterFn<O extends object, K extends keyof O> = (newValue: O[K]) => void;

  declare function createSetter<O extends object, K extends keyof O>(
      someObject: O,
      aKey: K
  ): SetterFn<O, K>  
  ```


---
### Todo
<!-- .element: class="todo" -->Beispiele zusammenstellen, die Nils macht  
<!-- .element: class="todo" -->* Das muss alles inklusive Übung in einer Stunde fertig sein!


---
### Mapped Types
* Ein fachliches Beispiel: eine `validatePerson`-Funktion soll ein `Person`-Objekt entgegennehmen und
  ein `ValidatedPerson`-Objekt zurückliefern
  * Das `ValidatedPerson`-Objekt enthält alle Properties von `Person` aber jeweils als `boolean`,
    um auszudrücken, ob der validierte Wert gültig ist oder nicht:
    * ```typescript
      type Person = {
        firstname: string;
        age: number;
      }

      type ValidatedPerson = {
        firstname: boolean;
        age: boolean;
      }

      declare function validatePerson(p: Person): ValidatedPerson;
      ```
* Mit einem [_Mapped Type_](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) kannst Du aus einem bestehenden Typen einen anderen generieren

---
### Mapped Types
  
* Der `ValidatePerson`-Typ kann generisch beschrieben werden, so dass er _automatisch_ alle Properties
  aus Person enthält, deren Typ aber nun jeweils `boolean` ist:
  * ```typescript
      type ValidatedPerson = {
        [Key in keyof Person]: boolean
      }
    ```
* Den Ausdruck `keyof Person` kennen wir schon: hier wird ein Union Typ zurückgeliefert, der aus allen Keys des Objekts besteht
* Mit `[Key in keyof Person]` wird an dieser Stelle über alle Keys in Person "iteriert" und der Typ des jeweiligen Keys in die Typ Variable `Key` geschrieben
  * hier also: `firstname` und dann `age`
  * `Key` ist ein Variablenname, den ihr frei vergeben könnt.
* Auf der rechten Seite vom Doppelpunkt steht (wie gewohnt) der Typ für das jeweilige Property (hier also: `boolean`)  
* Natürlich können wir alle möglichen Veränderungen im Ziel-Objekt vorgenommen werden, z.B. auch `readonly` hinzugefügt, oder Felder optional gemacht werden:
  * ```typescript
    type ValidatedPerson = {
      readonly [Key in keyof Person]?: boolean
    }
  ```
* Es gibt bereits fertige [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html) für eine Vielzahl typischer Anwendungsfälle,
  z.B. [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype), [Required](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype) oder [Readonly](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)
---
### Mapped Types #2

* Über den Index Access können wir beim Erzeugen des neuen Typen auf die ursprünglichen Typen der Properties des Original-Typen zugreifen
* Damit können wir zum Beispiel einen Typen bauen, der alle Properties aus dem ursprünglichen Typen hat, diese sind aber im neuen Typen nullable:
* ```typescript
  type NullablePerson = {
    [Key in keyof Person]: Person[Key] | null
  }

  // { firstname: string | null, age: number | null }
  ```
---
### Mapped Types mit Generics

* Ein Mapped Type wird besonders in Kombination mit Generics sehr mächtig
* Damit kannst Du _beliebige_ Typen in andere Typen transformieren:
* ```typescript
  type NullableObject<OBJECT extends object> = {
    [Key in keyof OBJECT]: OBJECT[Key] | null
  }

  type NullablePerson = NullableObject<Person>;
        // ^? { firstname: string | null, age: number | null }

  type NullableContact = NullableObject<{ phone: string, mobile: boolean >}
        // ^? { phone: string | null, mobile: boolean | null }
  ```

---
### Übung Mapped Types:

* Schreibe die Typ-Definitionen für eine generische Validation-Funktion!
  - Die fiktive `validate`-Funktion validiert ein übergebenes Objekt.
  - Der `validate`-Funktion wird als zweiten Parameter ein Objekt übergeben, 
    das eine Menge von Callback-Funktionen hat (`validatorFn`), in der jeweils die Validierungsregel für ein Property implementiert ist
  - Die `validate`-Funktion liefert ein Objekt zurück, in dem die Validierungsergebnisse der einzelnen Felder (true/false)
    enthalten sind
  - In JavaScript würde das z.B. so aussehen:    
  * ```typescript
    function validate(person, validators) { /* ... */ }

    const person = { firstname: "Mo", age: 32}
    const personValidators = { 
      firstname(s) { return s.length > 3 }, // s soll korrekt als 'string' abgeleitet werden
      age(a) { return age > 0 } // a soll korrekt als 'number' abgeleitet weden
    }
    const result = validate(person, personValidators);
          // ^ { firstname: boolean, age: boolean }
    ```
---
### Übung Mapped Types    
<!-- .element: class="todo" -->Hinweisen: entweder Typ für Validator-Objekt erst bauen, oder die validator-Funktionen beim Aufruf der Methode angeben, sonst kann TS die Argumente nicht ableiten
<!-- .element: class="todo" -->deswegen erst `ValidatorsObjekt` bauen (lassen)
* Die `validate`-Funktion soll zwei Parameter haben:
  1. Das zu validierende Objekt 
  2. Ein Objekt, das Funktionen zum Validieren enthält
    - Für jedes Property aus dem zu validierenden Objekt soll es eine (Callback-)_Funktion_ geben, die so heißt, wie das Property
    - Diese Funktion soll einen Parameter haben, der denselben Typ wie das Property hat und `true` oder `false` zurückliefern
* Die `validate`-Funktion soll ein Objekt zurückliefern, das dieselben Keys wie das zu validierende Objekt hat. Die Typen sollen aber jeweils `boolean` und `readonly` sein.
* Dann sollte folgendes funktionieren bzw. einen Fehler erzeugen:
<!-- .element: class="todo" -->todo: Lösung lieber in Übungsdatei, 
* ```typescript
const p = { firstname: "Klaus", lastname: "Meier", age: 32 };
personValidator.age?.(7); // OK
personValidator.age?.("fadfas"); // Argument of type 'string' is not assignable to parameter of type 'number'

  ```
---
### Mögliche Lösung
<!-- .slide: class="left" -->
* ```typescript
  // Ein Typ für das Ergebnis der validate-Funktion
  type ValidationResult<O> = {
    readonly [K in keyof O]: boolean;
  };

  // Typ für eine Validator Callback-Funktion
  type ValidatorFunction<V> = (value: V) => boolean;

  // Typ für das Objekt, das die Validator Callback-Funktionen enthält
  type ValidatorObject<O extends object> = {
    readonly [K in keyof O]: ValidatorFunction<O[K]>;
  };

  // die validateObjekt-Funktion
  declare function validateObject<O extends object>(
    o: O,
    validators: ValidatorObject<O>
  ) => ValidationResult<O>;
  ```


---
### Conditional Types

* Mit [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) kannst Du abhängig von einer Bedingung einen Typen oder einen anderen Typen auswählen
* Die Syntax dabei ist identisch mit dem ternären Operator (`?`) in JavaScript (`a === true ? "ja!" : "nein!"`)
* Nur dass dabei _Typen_ statt _Werte_ angegeben werden:
  * ```typescript
    type NumberOrNull<O> = O extends string ? number : null;

    type S = NumberOrNull<"huhu"> // N = number
    type N = NumberOrNull<123> // N = null
    type A = NumberOrNull<true>; // A = null
    ```
  * ```typescript
    type IsPerson<O> = O extends { firstname: string, lastname: string} ? true : false
    ```

* Conditional Types lassen sich verschachteln (genau wie beim ternären Operator):
  * ```typescript
    type NumberOrStringOrNull<O> = O extends string ? number 
                                 : O extends boolean ? string 
                                 : null

    type T1 = NumberOrStringOrNull<"huhu">; // T1 = string
    type T2 = NumberOrStringOrNull<123>; // T2 = null
    type T3 = NumberOrStringOrNull<true>; // T3 = string     
    ```
    
---
### Verwendung von Conditional Types
    
* Beispiel: 
  * Eine Funktion nimmt einen `string` oder `null` entgegen. 
  * Wenn sie mit `string` aufgerufen wurde, soll sie dessen Länge zurückgeben (`number`)
  * Wenn sie mit `null` aufgerufen wurde, soll sie `null` zurückliefern
  * ```typescript
    // So geht's nicht 😢
    declare function getLength(s: string | null): number | null; 

    const a = getLength("123"); // a: number | null 
    const b = getLength(null); // b: number | null
    ```
* Mit Generics und einem Conditional Type lässt sich das umsetzen: 
* ```typescript
    declare function getLength<O extends string | null>(s: O): O extends string ? number : null;

    const a = getLength("123"); // a: number
    const b = getLength(null); // b: null
  ```

---
### Conditional Types mit Union Types

* Wenn Du einen _Union Type_ übergibst, wird die Überprüfung für jeden Typen aus dem Union Type durchgeführt und ein neuer Union Type zurückgeliefert:
* ```typescript
  type NumberOrNull<O> = O extends string ? number : null;

  type R = NumberOrNull<string | null | boolean>; 
    // R = number | null:
    // string wird zu 'number'
    // null und boolean werden beide zu 'null'
  ```

---
### Conditional Types mit `never`

* Wenn `never` in einem _Union Type_ vorkommt, wird dieser Typ "herausgefiltert"
* ```typescript
  type X = string | boolean | never; // X = string | boolean
  ```
* Das kanst Du nutzen, um mit einem Conditional Type aus einer Liste von Typen welche herauszufiltern
* ```typescript
  type NotNull<O> = O extends null ? never : O
  type T = NotNull<string>; T = string
  type T1 = NotNull<string | null>; // T1 = string
  type T2 = NotNull<string | boolean | null | undefined>; // T2 = string | boolean | undefined

  // Macht hier kein Sinn, aber s. weiteres Beispiel später
  type TX = NotNull<null>; // T2 = never
  ```
* `extends` kann ebenfalls einen Union Typen aufnehmen:
* ```typescript
  type NotNullOrUndefined<O> = O extends null | undefined ? never : O
  type T3 = NotNullOrUndefined<string | null>; // T3 = string
  type T4 = NotNullOrUndefined<string | boolean | undefined>; // T4 = string | boolean
  ```
---
### Conditional Types mit `never`
* Fachliches Beispiel: eine Funktion, die sicherstellt, dass ein Wert nicht null ist
* Wenn der übergebene Wert `null` ist, wirft die Funktion zum Beispiel einen Fehler
* Wenn der Wert nicht `null` ist, liefert die Funktion den Wert zurück
* ```typescript
  declare function ensureNotNull<O>(o: O): NotNull<O>;

  const c = ensureNotNull("huhu"); // c = string

  // hier macht 'never' jetzt Sinn, da die Funktion 
  // tatsächlich nie zurückkommt
  const b = ensureNotNull(null); // b = never
  ```
---
### Type Inference mit Conditional Types

* Mit einem Conditional Type können wir nicht nur Typen überprüfen, sondern auch Typen _extrahieren_ lassen
* Beispiel:
  * Eine Funktion nimmt einen Parameter entgegen
  * Der Rückgabetyp soll dem Typen des Parameters entsprechen. Wie das geht, haben wir schon gesehen:
  * ```typescript
    declare function check<O>(o: O): O;
    ```
  * Wenn der übergebene Parameter aber selbst eine Funktion ist, soll deren(!) Rückgabetyp zurückgeliefert werden:
  * ```typescript
    check( () => 123 ); // Rückgabetyp soll number sein
    check( () => "Hallo" ); // Rückgabetyp soll string sein
    ```
---
###  Type Inference mit Conditional Types 
  * Mit einem Conditional-Type können wir prüfen, ob der Parameter ein Funktion ist:
  * ```typescript
    O extends (...a: any) => any ? /* Funktion */ : /* Keine Funktion */
    ```
* Wenn der Ausdruck des Conditional Types _true_ ist, wissen wir das es eine Funktion ist. In dem Fall können wir mit `infer` die Typen der Parameter
  und/oder des Rückgabewertes extrahieren und in eine neue Typ-Variable schreiben lassen.
  * ```typescript
  O extends (...a: any) => infer A ? 
     /* Funktion: hier haben wir jetzt O und A */ 
     : 
     /* Keine Funktion, nur O */
    ```
  * Das können wir nun nutzen, um unsere Anforderung umzusetzen:
  * ```typescript
    declare function check<O>(o: O): O extends (...a: any) => infer A ? A : O
    ```
---
###  Type Inference mit Conditional Types 
* Weitere Beispiele
* ```typescript
  // Ermitteln eines Arguments:
  type FirstArg<O> = O extends (a: infer A, ...args: any) => any ? A : never
  ```

* ```typescript
  // Typ eines Arrays ermitteln
  type TypeOfArray<A> = A extends (infer A)[] ? A : never

  type T1 = TypeOfArray<string[]> // string
  type T2 = TypeOfArray<string>; // never
  ```
* Für typische Anforderungen gibt es bereits fertige _Utility Typen_, z.B.:
  * [Awaited](https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype): Liefert Typ von Promises zurück
  * [ReturnType](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype): Rückgabe-Typ einer Methode
  * [InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype): Typ der Instanz einer Klasse
  



---
### Mögliche Übung:

- Teil 1:
- Baue einen Typen, der aus einer Liste von Typen einen gewählten Typen ausschliesst
  - bräuchten wir für den nächsten Teil...
- Teil 2:
 - Idee: eine Funktion, die alles aus einem Objekt filtert, das eine Funktion ist (z.B. vor Übertragen an Server)
 - Baue einen Typen, der ein Objekt entgegennimmt und aus dem alle Einträge rauswirft, die Funktionen sind
 -  `as` erklären
 -  Sollte auf Teil 1 aufbauen, sonst Teil 1 raus

- Ein Typ, der ein Objekt erwartet und in das Ziel-Objekt nur solche Properties übernimmt, die im Original ein string sind
  ( oder vom angegebenen Typen)
- 
type X2 = {
  [K in keyof P as K extends string ? K : never]: P[K]
}    
- Extract (z.B. mit Fussballteams, weil das lustiger und nicht so trocken ist)
- Wie könnte man dem Benutzer eine sprechende Fehlermeldung (statt never) geben

---
### String Template Literal

---
### Übung: String Template Literal



- Übung

---
### todo
<!-- .element: class="todo" -->
* Alle Übungen kontrollieren: die sollen alle eine "fachliche MOtivation" haben


          
          </textarea>
        </section>
        <section>
          <h2>Geschafft! 😊</h2>
          <h3>Vielen Dank für Eure Teilnahme!</h3>
          <h3>Viel Spaß und Erfolg mit TypeScript!</h3>
          <p>Wenn ihr noch Fragen habt, könnt ihr mich erreichen:</p>
          <p>
            Mail:
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            Web:
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            Mastodon:
            <a href="https://norden.social/@nilshartmann" target="_blank"
              >@nilshartmann@norden.social
            </a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
